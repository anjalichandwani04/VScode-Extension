{ "__init__": { "open3d.camera.PinholeCameraIntrinsic": "Overloaded function.", "open3d.camera.PinholeCameraParameters": "Overloaded function.", "open3d.camera.PinholeCameraTrajectory": "Overloaded function.", "open3d.core.Blob": "Initialize self. See help (type (self)) for accurate signature.", "open3d.core.Device": "Overloaded function.", "open3d.core.DynamicSizeVector": "Overloaded function.", "open3d.core.HashMap": "Overloaded function.", "open3d.core.HashSet": "init_capacity (int) \u2013 Initial capacity of a hash container.", "open3d.core.Scalar": "Overloaded function.", "open3d.core.SizeVector": "Overloaded function.", "open3d.core.Tensor": "Overloaded function.", "open3d.data.DataDescriptor": "Overloaded function.", "open3d.geometry.AxisAlignedBoundingBox": "Overloaded function.", "open3d.geometry.Geometry": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.Geometry2D": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.Geometry3D": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.HalfEdge": "Overloaded function.", "open3d.geometry.HalfEdgeTriangleMesh": "Overloaded function.", "open3d.geometry.Image": "Overloaded function.", "open3d.geometry.KDTreeFlann": "Overloaded function.", "open3d.geometry.KDTreeSearchParam": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.LineSet": "Overloaded function.", "open3d.geometry.MeshBase": "Overloaded function.", "open3d.geometry.Octree": "Overloaded function.", "open3d.geometry.OctreeColorLeafNode": "Overloaded function.", "open3d.geometry.OctreeInternalNode": "Overloaded function.", "open3d.geometry.OctreeInternalPointNode": "Overloaded function.", "open3d.geometry.OctreeLeafNode": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.OctreeNode": "Initialize self. See help (type (self)) for accurate signature.", "open3d.geometry.OctreeNodeInfo": "origin (numpy.ndarray[numpy.float64[3, 1]]) \u2013", "open3d.geometry.OctreePointColorLeafNode": "Overloaded function.", "open3d.geometry.OrientedBoundingBox": "Overloaded function.", "open3d.geometry.PointCloud": "Overloaded function.", "open3d.geometry.RGBDImage": "Default constructor", "open3d.geometry.TetraMesh": "Overloaded function.", "open3d.geometry.TriangleMesh": "Overloaded function.", "open3d.geometry.Voxel": "Overloaded function.", "open3d.geometry.VoxelGrid": "Overloaded function.", "open3d.io.AzureKinectMKVMetadata": "Default constructor", "open3d.io.AzureKinectSensorConfig": "Overloaded function.", "open3d.io.rpc.Connection": "Creates a connection object", "open3d.ml.tf.dataloaders.TFDataloader": "Initializes the object, and includes the following steps:", "open3d.ml.tf.datasets.Argoverse": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.Custom3D": "Initialize the class by passing the dataset path.", "open3d.ml.tf.datasets.InferenceDummySplit": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.datasets.KITTI": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.Lyft": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.MatterportObjects": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.NuScenes": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.ParisLille3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.S3DIS": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.Scannet": "Initialize the dataset by passing the dataset and other details.", "open3d.ml.tf.datasets.SemSegRandomSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.datasets.SemSegSpatiallyRegularSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.datasets.Semantic3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.SemanticKITTI": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.ShapeNet": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.SunRGBD": "Initialize the dataset by passing the dataset and other details.", "open3d.ml.tf.datasets.Toronto3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.Waymo": "Initialize the function by passing the dataset and other details.", "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.datasets.utils.BEVBox3D": "Creates a bounding box.", "open3d.ml.tf.models.KPFCNN": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.PVCNN": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.PointPillars": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.PointRCNN": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.PointTransformer": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.RandLANet": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.models.SparseConvUnet": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.modules.losses.CrossEntropyLoss": "CrossEntropyLoss.", "open3d.ml.tf.modules.losses.FocalLoss": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.modules.losses.SemSegLoss": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.modules.losses.SmoothL1Loss": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.modules.metrics.SemSegMetric": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.pipelines.ObjectDetection": "Initialize.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Initialize.", "open3d.ml.tf.vis.BoundingBox3D": "Creates a bounding box.", "open3d.ml.tf.vis.Colormap.Point": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.DataModel": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.DatasetModel": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.LabelLUT.Label": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.Model.BoundingBoxData": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.Visualizer.ColormapEdit": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.tf.vis.deque": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.classes.RaggedTensor": "Creates a RaggedTensor with specified torch script object.", "open3d.ml.torch.dataloaders.ConcatBatcher": "Initialize.", "open3d.ml.torch.dataloaders.DefaultBatcher": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.dataloaders.TorchDataloader": "Initialize.", "open3d.ml.torch.datasets.Argoverse": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.Custom3D": "Initialize the class by passing the dataset path.", "open3d.ml.torch.datasets.InferenceDummySplit": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.KITTI": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.Lyft": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.MatterportObjects": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.NuScenes": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.ParisLille3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.S3DIS": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.Scannet": "Initialize the dataset by passing the dataset and other details.", "open3d.ml.torch.datasets.SemSegRandomSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.SemSegSpatiallyRegularSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.Semantic3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.SemanticKITTI": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.ShapeNet": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.SunRGBD": "Initialize the dataset by passing the dataset and other details.", "open3d.ml.torch.datasets.Toronto3D": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.Waymo": "Initialize the function by passing the dataset and other details.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.samplers.SemSegRandomSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.samplers.SemSegSpatiallyRegularSampler": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.datasets.utils.BEVBox3D": "Creates a bounding box.", "open3d.ml.torch.layers.ContinuousConv": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.FixedRadiusSearch": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.KNNSearch": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.RadiusSearch": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.SparseConv": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.SparseConvTranspose": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.layers.VoxelPooling": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.models.KPFCNN": "Initialize.", "open3d.ml.torch.models.PVCNN": "Initialize.", "open3d.ml.torch.models.PointPillars": "Initialize.", "open3d.ml.torch.models.PointRCNN": "Initialize.", "open3d.ml.torch.models.PointTransformer": "Initialize.", "open3d.ml.torch.models.RandLANet": "Initialize.", "open3d.ml.torch.models.SparseConvUnet": "Initialize.", "open3d.ml.torch.modules.losses.CrossEntropyLoss": "CrossEntropyLoss.", "open3d.ml.torch.modules.losses.FocalLoss": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.modules.losses.SemSegLoss": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.modules.losses.SmoothL1Loss": "Initializes internal Module state, shared by both nn.Module and ScriptModule.", "open3d.ml.torch.modules.metrics.SemSegMetric": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.pipelines.ObjectDetection": "Initialize.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Initialize.", "open3d.ml.torch.vis.BoundingBox3D": "Creates a bounding box.", "open3d.ml.torch.vis.Colormap.Point": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.DataModel": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.DatasetModel": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.LabelLUT.Label": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.Model.BoundingBoxData": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.Visualizer.ColormapEdit": "Initialize self. See help (type (self)) for accurate signature.", "open3d.ml.torch.vis.deque": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.color_map.NonRigidOptimizerOption": "number_of_vertical_anchors (int, optional, default=16) \u2013 int: (Default 16) Number of vertical anchor points for image wrapping field. The number of horizontal anchor points is computed automatically based on the number of vertical anchor points. This option is only used when non-rigid optimization is enabled.", "open3d.pipelines.color_map.RigidOptimizerOption": "maximum_iteration (int, optional, default=0) \u2013 int: (Default 300) Number of iterations for optimization steps.", "open3d.pipelines.integration.ScalableTSDFVolume": "Overloaded function.", "open3d.pipelines.integration.TSDFVolume": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.integration.UniformTSDFVolume": "Overloaded function.", "open3d.pipelines.odometry.RGBDOdometryJacobian": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.odometry.RGBDOdometryJacobianFromColorTerm": "Overloaded function.", "open3d.pipelines.odometry.RGBDOdometryJacobianFromHybridTerm": "Overloaded function.", "open3d.pipelines.registration.CauchyLoss": "Overloaded function.", "open3d.pipelines.registration.CorrespondenceChecker": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance": "Overloaded function.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength": "Overloaded function.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnNormal": "Overloaded function.", "open3d.pipelines.registration.FastGlobalRegistrationOption": "Overloaded function.", "open3d.pipelines.registration.Feature": "Overloaded function.", "open3d.pipelines.registration.GMLoss": "Overloaded function.", "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Overloaded function.", "open3d.pipelines.registration.GlobalOptimizationGaussNewton": "Overloaded function.", "open3d.pipelines.registration.GlobalOptimizationLevenbergMarquardt": "Overloaded function.", "open3d.pipelines.registration.GlobalOptimizationMethod": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.registration.GlobalOptimizationOption": "Overloaded function.", "open3d.pipelines.registration.HuberLoss": "Overloaded function.", "open3d.pipelines.registration.ICPConvergenceCriteria": "Overloaded function.", "open3d.pipelines.registration.L1Loss": "Overloaded function.", "open3d.pipelines.registration.L2Loss": "Overloaded function.", "open3d.pipelines.registration.PoseGraph": "Overloaded function.", "open3d.pipelines.registration.PoseGraphEdge": "Overloaded function.", "open3d.pipelines.registration.PoseGraphEdgeVector": "Overloaded function.", "open3d.pipelines.registration.PoseGraphNode": "Overloaded function.", "open3d.pipelines.registration.PoseGraphNodeVector": "Overloaded function.", "open3d.pipelines.registration.RANSACConvergenceCriteria": "Overloaded function.", "open3d.pipelines.registration.RegistrationResult": "Overloaded function.", "open3d.pipelines.registration.RobustKernel": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.registration.TransformationEstimation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.pipelines.registration.TransformationEstimationForColoredICP": "Overloaded function.", "open3d.pipelines.registration.TransformationEstimationForGeneralizedICP": "Overloaded function.", "open3d.pipelines.registration.TransformationEstimationPointToPlane": "Overloaded function.", "open3d.pipelines.registration.TransformationEstimationPointToPoint": "Overloaded function.", "open3d.pipelines.registration.TukeyLoss": "Overloaded function.", "open3d.t.geometry.AxisAlignedBoundingBox": "Overloaded function.", "open3d.t.geometry.DrawableGeometry": "Initialize self. See help (type (self)) for accurate signature.", "open3d.t.geometry.Geometry": "Initialize self. See help (type (self)) for accurate signature.", "open3d.t.geometry.Image": "Overloaded function.", "open3d.t.geometry.LineSet": "Overloaded function.", "open3d.t.geometry.PointCloud": "Overloaded function.", "open3d.t.geometry.RGBDImage": "Overloaded function.", "open3d.t.geometry.RaycastingScene": "Create a RaycastingScene.", "open3d.t.geometry.TensorMap": "Overloaded function.", "open3d.t.geometry.TriangleMesh": "Overloaded function.", "open3d.t.io.DepthNoiseSimulator": "noise_model_path (str) \u2013 Path to the noise model file. See __URL__ for the format. Or, you may use one of our example datasets, e.g., RedwoodIndoorLivingRoom1.", "open3d.t.io.RGBDSensor": "Initialize self. See help (type (self)) for accurate signature.", "open3d.t.io.RSBagReader": "Overloaded function.", "open3d.t.io.RealSenseSensor": "Initialize with default settings.", "open3d.t.io.RealSenseSensorConfig": "Overloaded function.", "open3d.t.io.RealSenseValidConfigs": "Initialize self. See help (type (self)) for accurate signature.", "open3d.t.pipelines.odometry.OdometryConvergenceCriteria": "Overloaded function.", "open3d.t.pipelines.odometry.OdometryLossParams": "Overloaded function.", "open3d.t.pipelines.odometry.OdometryResult": "Overloaded function.", "open3d.t.pipelines.registration.ICPConvergenceCriteria": "Overloaded function.", "open3d.t.pipelines.registration.RegistrationResult": "Overloaded function.", "open3d.t.pipelines.registration.TransformationEstimation": "Initialize self. See help (type (self)) for accurate signature.", "open3d.t.pipelines.registration.TransformationEstimationForColoredICP": "Overloaded function.", "open3d.t.pipelines.registration.TransformationEstimationPointToPlane": "Overloaded function.", "open3d.t.pipelines.registration.TransformationEstimationPointToPoint": "Overloaded function.", "open3d.t.pipelines.slac.control_grid": "Overloaded function.", "open3d.t.pipelines.slac.slac_debug_option": "Overloaded function.", "open3d.t.pipelines.slac.slac_optimizer_params": "Overloaded function.", "open3d.t.pipelines.slam.Frame": "Overloaded function.", "open3d.t.pipelines.slam.Model": "Overloaded function.", "open3d.utility.DoubleVector": "Overloaded function.", "open3d.utility.IntVector": "Overloaded function.", "open3d.utility.Matrix3dVector": "Overloaded function.", "open3d.utility.Matrix4dVector": "Overloaded function.", "open3d.utility.Vector2dVector": "Overloaded function.", "open3d.utility.Vector2iVector": "Overloaded function.", "open3d.utility.Vector3dVector": "Overloaded function.", "open3d.utility.Vector3iVector": "Overloaded function.", "open3d.utility.Vector4iVector": "Overloaded function.", "open3d.utility.VerbosityContextManager": "Create a VerbosityContextManager with a given VerbosityLevel", "open3d.visualization.ExternalVisualizer": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.Material": "Overloaded function.", "open3d.visualization.O3DVisualizer.DrawObject": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.RenderOption": "Default constructor", "open3d.visualization.SelectedIndex": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.SelectionPolygonVolume": "Overloaded function.", "open3d.visualization.ViewControl": "Default constructor", "open3d.visualization.Visualizer": "Default constructor", "open3d.visualization.VisualizerWithEditing": "Overloaded function.", "open3d.visualization.VisualizerWithKeyCallback": "Default constructor", "open3d.visualization.VisualizerWithVertexSelection": "Overloaded function.", "open3d.visualization.gui.Application": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.Button": "Creates a button with the given text", "open3d.visualization.gui.CheckableTextTreeCell": "Creates a TreeView cell with a checkbox and text. CheckableTextTreeCell (text, is_checked, on_toggled): on_toggled takes a boolean and returns None", "open3d.visualization.gui.Checkbox": "Creates a checkbox with the given text", "open3d.visualization.gui.CollapsableVert": "Overloaded function.", "open3d.visualization.gui.ColormapTreeCell": "Creates a TreeView cell with a number and a color edit. ColormapTreeCell (value, color, on_value_changed, on_color_changed): on_value_changed takes a double and returns None; on_color_changed takes a gui.Color and returns None", "open3d.visualization.gui.Combobox": "Creates an empty combobox. Use add_item () to add items", "open3d.visualization.gui.Dialog": "Creates a dialog with the given title", "open3d.visualization.gui.FileDialog": "Creates either an open or save file dialog. The first parameter is either FileDialog.OPEN or FileDialog.SAVE. The second is the title of the dialog, and the third is the theme, which is used internally by the dialog for layout. The theme should normally be retrieved from window.theme.", "open3d.visualization.gui.FontDescription": "Creates a FontDescription. \u2018typeface\u2019 is a path to a TrueType (.ttf), TrueType Collection (.ttc), or OpenType (.otf) file, or it is the name of the font, in which case the system font paths will be searched to find the font file. This typeface will be used for roman characters (Extended Latin, that is, European languages", "open3d.visualization.gui.Horiz": "Overloaded function.", "open3d.visualization.gui.ImageWidget": "Overloaded function.", "open3d.visualization.gui.KeyEvent": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.LUTTreeCell": "Creates a TreeView cell with a checkbox, text, and a color editor. LUTTreeCell (text, is_checked, color, on_enabled, on_color): on_enabled is called when the checkbox toggles, and takes a boolean and returns None; on_color is called when the user changes the color and it takes a gui.Color and returns None.", "open3d.visualization.gui.Label": "Creates a Label with the given text", "open3d.visualization.gui.Label3D": "Create a 3D Label with given text and position", "open3d.visualization.gui.Layout1D": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.LayoutContext": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.ListView": "Creates an empty list", "open3d.visualization.gui.Margins": "Overloaded function.", "open3d.visualization.gui.MouseEvent": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.NumberEdit": "Creates a NumberEdit that is either integers (INT) or floating point (DOUBLE). The initial value is 0 and the limits are +/- max integer (roughly).", "open3d.visualization.gui.RadioButton": "Creates an empty radio buttons. Use set_items () to add items", "open3d.visualization.gui.Rect": "Overloaded function.", "open3d.visualization.gui.SceneWidget": "Creates an empty SceneWidget. Assign a Scene with the \u2018scene\u2019 property", "open3d.visualization.gui.ScrollableVert": "Overloaded function.", "open3d.visualization.gui.Size": "Overloaded function.", "open3d.visualization.gui.Slider": "Creates a NumberEdit that is either integers (INT) or floating point (DOUBLE). The initial value is 0 and the limits are +/- infinity.", "open3d.visualization.gui.TextEdit": "Creates a TextEdit widget with an initial value of an empty string.", "open3d.visualization.gui.Theme": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.ToggleSwitch": "Creates a toggle switch with the given text", "open3d.visualization.gui.TreeView": "Creates an empty TreeView widget", "open3d.visualization.gui.UIImage": "Overloaded function.", "open3d.visualization.gui.VGrid": "Overloaded function.", "open3d.visualization.gui.Vert": "Overloaded function.", "open3d.visualization.gui.WidgetProxy": "Creates a widget proxy", "open3d.visualization.gui.WidgetStack": "Creates a widget stack. The widget stack without anywidget will not be shown in GUI until set_widget iscalled to push a widget.", "open3d.visualization.gui.Window": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.gui.WindowBase": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.rendering.Camera": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.rendering.Gradient": "Overloaded function.", "open3d.visualization.rendering.OffscreenRenderer": "Takes width, height and optionally a resource_path. If unspecified, resource_path will use the resource path from the installed Open3D library.", "open3d.visualization.rendering.Renderer": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.rendering.Scene": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.rendering.View": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.tensorboard_plugin.summary.BoundingBox3D": "Creates a bounding box.", "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Creates a SummaryWriter that will write out events and summaries to the event file.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Initialize self. See help (type (self)) for accurate signature.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Initialize self. See help (type (self)) for accurate signature." }, "get_focal_length": { "open3d.camera.PinholeCameraIntrinsic": "Returns the focal length in a tuple of X-axis and Y-axisfocal lengths." }, "get_principal_point": { "open3d.camera.PinholeCameraIntrinsic": "Returns the principle point in a tuple of X-axis and.Y-axis principle points" }, "get_skew": { "open3d.camera.PinholeCameraIntrinsic": "Returns the skew." }, "is_valid": { "open3d.camera.PinholeCameraIntrinsic": "Returns True iff both the width and height are greater than 0.", "open3d.visualization.Material": "Returns false if material is an empty material" }, "set_intrinsics": { "open3d.camera.PinholeCameraIntrinsic": "Set camera intrinsic parameters." }, "height": { "open3d.camera.PinholeCameraIntrinsic": "Height of the image.", "open3d.io.AzureKinectMKVMetadata": "Height of the video", "open3d.t.io.RGBDVideoMetadata": "Height of the video" }, "intrinsic_matrix": { "open3d.camera.PinholeCameraIntrinsic": "Intrinsic camera matrix [[fx, 0, cx], [0, fy, cy], [0, 0, 1]]" }, "width": { "open3d.camera.PinholeCameraIntrinsic": "Width of the image.", "open3d.io.AzureKinectMKVMetadata": "Width of the video", "open3d.t.io.RGBDVideoMetadata": "Width of the video" }, "extrinsic": { "open3d.camera.PinholeCameraParameters": "Camera extrinsic parameters." }, "intrinsic": { "open3d.camera.PinholeCameraParameters": "PinholeCameraIntrinsic object." }, "parameters": { "open3d.camera.PinholeCameraTrajectory": "List of PinholeCameraParameters objects." }, "append": { "open3d.core.DynamicSizeVector": "Add an item to the end of the list", "open3d.core.SizeVector": "Add an item to the end of the list", "open3d.core.Tensor": "Appends the values tensor, along the given axis and returns a copy of the original tensor. Both the tensors must have same data-type device, and number of dimensions. All dimensions must be the same, except the dimension along the axis the tensors are to be appended.", "open3d.ml.tf.vis.deque": "Add an element to the right side of the deque.", "open3d.ml.torch.vis.deque": "Add an element to the right side of the deque.", "open3d.pipelines.registration.PoseGraphEdgeVector": "Add an item to the end of the list", "open3d.pipelines.registration.PoseGraphNodeVector": "Add an item to the end of the list", "open3d.utility.DoubleVector": "Add an item to the end of the list", "open3d.utility.IntVector": "Add an item to the end of the list", "open3d.utility.Matrix3dVector": "Add an item to the end of the list", "open3d.utility.Matrix4dVector": "Add an item to the end of the list", "open3d.utility.Vector2dVector": "Add an item to the end of the list", "open3d.utility.Vector2iVector": "Add an item to the end of the list", "open3d.utility.Vector3dVector": "Add an item to the end of the list", "open3d.utility.Vector3iVector": "Add an item to the end of the list", "open3d.utility.Vector4iVector": "Add an item to the end of the list" }, "clear": { "open3d.core.DynamicSizeVector": "Clear the contents", "open3d.core.SizeVector": "Clear the contents", "open3d.geometry.AxisAlignedBoundingBox": "Clear all elements in the geometry.", "open3d.geometry.Geometry": "Clear all elements in the geometry.", "open3d.geometry.Geometry2D": "Clear all elements in the geometry.", "open3d.geometry.Geometry3D": "Clear all elements in the geometry.", "open3d.geometry.HalfEdgeTriangleMesh": "Clear all elements in the geometry.", "open3d.geometry.Image": "Clear all elements in the geometry.", "open3d.geometry.LineSet": "Clear all elements in the geometry.", "open3d.geometry.MeshBase": "Clear all elements in the geometry.", "open3d.geometry.Octree": "Clear all elements in the geometry.", "open3d.geometry.OrientedBoundingBox": "Clear all elements in the geometry.", "open3d.geometry.PointCloud": "Clear all elements in the geometry.", "open3d.geometry.RGBDImage": "Clear all elements in the geometry.", "open3d.geometry.TetraMesh": "Clear all elements in the geometry.", "open3d.geometry.TriangleMesh": "Clear all elements in the geometry.", "open3d.geometry.VoxelGrid": "Clear all elements in the geometry.", "open3d.ml.tf.vis.Visualizer.LabelLUTEdit": "Clears the look-up table.", "open3d.ml.tf.vis.deque": "Remove all elements from the deque.", "open3d.ml.torch.vis.Visualizer.LabelLUTEdit": "Clears the look-up table.", "open3d.ml.torch.vis.deque": "Remove all elements from the deque.", "open3d.pipelines.registration.PoseGraphEdgeVector": "Clear the contents", "open3d.pipelines.registration.PoseGraphNodeVector": "Clear the contents", "open3d.t.geometry.AxisAlignedBoundingBox": "Clear all elements in the geometry.", "open3d.t.geometry.Geometry": "Clear all elements in the geometry.", "open3d.t.geometry.Image": "Clear stored data.", "open3d.t.geometry.LineSet": "Clear all elements in the geometry.", "open3d.t.geometry.PointCloud": "Clear all elements in the geometry.", "open3d.t.geometry.RGBDImage": "Clear stored data.", "open3d.t.geometry.TriangleMesh": "Clear all elements in the geometry.", "open3d.utility.DoubleVector": "Clear the contents", "open3d.utility.IntVector": "Clear the contents", "open3d.utility.Matrix3dVector": "Clear the contents", "open3d.utility.Matrix4dVector": "Clear the contents", "open3d.utility.Vector2dVector": "Clear the contents", "open3d.utility.Vector2iVector": "Clear the contents", "open3d.utility.Vector3dVector": "Clear the contents", "open3d.utility.Vector3iVector": "Clear the contents", "open3d.utility.Vector4iVector": "Clear the contents", "open3d.visualization.gui.TreeView": "Removes all items" }, "count": { "open3d.core.DynamicSizeVector": "Return the number of times x appears in the list", "open3d.core.SizeVector": "Return the number of times x appears in the list", "open3d.utility.DoubleVector": "Return the number of times x appears in the list", "open3d.utility.IntVector": "Return the number of times x appears in the list", "open3d.utility.Matrix3dVector": "Return the number of times x appears in the list", "open3d.utility.Matrix4dVector": "Return the number of times x appears in the list", "open3d.utility.Vector2dVector": "Return the number of times x appears in the list", "open3d.utility.Vector2iVector": "Return the number of times x appears in the list", "open3d.utility.Vector3dVector": "Return the number of times x appears in the list", "open3d.utility.Vector3iVector": "Return the number of times x appears in the list", "open3d.utility.Vector4iVector": "Return the number of times x appears in the list" }, "extend": { "open3d.core.DynamicSizeVector": "Overloaded function.", "open3d.core.SizeVector": "Overloaded function.", "open3d.ml.tf.vis.deque": "Extend the right side of the deque with elements from the iterable", "open3d.ml.torch.vis.deque": "Extend the right side of the deque with elements from the iterable", "open3d.pipelines.registration.PoseGraphEdgeVector": "Overloaded function.", "open3d.pipelines.registration.PoseGraphNodeVector": "Overloaded function.", "open3d.utility.DoubleVector": "Overloaded function.", "open3d.utility.IntVector": "Overloaded function.", "open3d.utility.Matrix3dVector": "Overloaded function.", "open3d.utility.Matrix4dVector": "Overloaded function.", "open3d.utility.Vector2dVector": "Overloaded function.", "open3d.utility.Vector2iVector": "Overloaded function.", "open3d.utility.Vector3dVector": "Overloaded function.", "open3d.utility.Vector3iVector": "Overloaded function.", "open3d.utility.Vector4iVector": "Overloaded function." }, "insert": { "open3d.core.DynamicSizeVector": "Insert an item at a given position.", "open3d.core.HashMap": "Overloaded function.", "open3d.core.HashSet": "Insert an array of keys stored in Tensors.", "open3d.core.SizeVector": "Insert an item at a given position.", "open3d.ml.tf.vis.deque": "D.insert (index, object) \u2013 insert object before index", "open3d.ml.torch.vis.deque": "D.insert (index, object) \u2013 insert object before index", "open3d.pipelines.registration.PoseGraphEdgeVector": "Insert an item at a given position.", "open3d.pipelines.registration.PoseGraphNodeVector": "Insert an item at a given position.", "open3d.utility.DoubleVector": "Insert an item at a given position.", "open3d.utility.IntVector": "Insert an item at a given position.", "open3d.utility.Matrix3dVector": "Insert an item at a given position.", "open3d.utility.Matrix4dVector": "Insert an item at a given position.", "open3d.utility.Vector2dVector": "Insert an item at a given position.", "open3d.utility.Vector2iVector": "Insert an item at a given position.", "open3d.utility.Vector3dVector": "Insert an item at a given position.", "open3d.utility.Vector3iVector": "Insert an item at a given position.", "open3d.utility.Vector4iVector": "Insert an item at a given position." }, "pop": { "open3d.core.DynamicSizeVector": "Overloaded function.", "open3d.core.SizeVector": "Overloaded function.", "open3d.ml.tf.vis.deque": "Remove and return the rightmost element.", "open3d.ml.torch.vis.deque": "Remove and return the rightmost element.", "open3d.pipelines.registration.PoseGraphEdgeVector": "Overloaded function.", "open3d.pipelines.registration.PoseGraphNodeVector": "Overloaded function.", "open3d.utility.DoubleVector": "Overloaded function.", "open3d.utility.IntVector": "Overloaded function.", "open3d.utility.Matrix3dVector": "Overloaded function.", "open3d.utility.Matrix4dVector": "Overloaded function.", "open3d.utility.Vector2dVector": "Overloaded function.", "open3d.utility.Vector2iVector": "Overloaded function.", "open3d.utility.Vector3dVector": "Overloaded function.", "open3d.utility.Vector3iVector": "Overloaded function.", "open3d.utility.Vector4iVector": "Overloaded function." }, "remove": { "open3d.core.DynamicSizeVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.core.SizeVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.ml.tf.vis.deque": "D.remove (value) \u2013 remove first occurrence of value.", "open3d.ml.torch.vis.deque": "D.remove (value) \u2013 remove first occurrence of value.", "open3d.utility.DoubleVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.IntVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Matrix3dVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Matrix4dVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Vector2dVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Vector2iVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Vector3dVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Vector3iVector": "Remove the first item from the list whose value is x. It is an error if there is no such item.", "open3d.utility.Vector4iVector": "Remove the first item from the list whose value is x. It is an error if there is no such item." }, "activate": { "open3d.core.HashMap": "Activate an array of keys stored in Tensors without copying values." }, "active_buf_indices": { "open3d.core.HashMap": "Get the buffer indices corresponding to active entries in the hash map.", "open3d.core.HashSet": "Get the buffer indices corresponding to active entries in the hash set." }, "capacity": { "open3d.core.HashMap": "Get the capacity of the hash map.", "open3d.core.HashSet": "Get the capacity of the hash set." }, "clone": { "open3d.core.HashMap": "Clone the hash map, including the data structure and the data buffers.", "open3d.core.HashSet": "Clone the hash set, including the data structure and the data buffers.", "open3d.core.Tensor": "Copy Tensor to the same device.", "open3d.geometry.OctreeColorLeafNode": "Clone this OctreeLeafNode.", "open3d.geometry.OctreeLeafNode": "Clone this OctreeLeafNode.", "open3d.geometry.OctreePointColorLeafNode": "Clone this OctreeLeafNode.", "open3d.ml.torch.classes.RaggedTensor": "Returns a clone of object.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns copy of the axis-aligned box on the same device.", "open3d.t.geometry.Image": "Returns a copy of the Image on the same device.", "open3d.t.geometry.LineSet": "Returns copy of the line set on the same device.", "open3d.t.geometry.PointCloud": "Returns a copy of the point cloud on the same device.", "open3d.t.geometry.RGBDImage": "Returns a copy of the RGBDImage on the same device.", "open3d.t.geometry.TriangleMesh": "Returns copy of the triangle mesh on the same device." }, "cpu": { "open3d.core.HashMap": "Transfer the hash map to CPU. If the hash map is already on CPU, no copy will be performed.", "open3d.core.HashSet": "Transfer the hash set to CPU. If the hash set is already on CPU, no copy will be performed.", "open3d.core.Tensor": "Transfer the tensor to CPU. If the tensor is already on CPU, no copy will be performed.", "open3d.t.geometry.AxisAlignedBoundingBox": "Transfer the axis-aligned box to CPU. If the axis-aligned box is already on CPU, no copy will be performed.", "open3d.t.geometry.Image": "Transfer the image to CPU. If the image is already on CPU, no copy will be performed.", "open3d.t.geometry.LineSet": "Transfer the line set to CPU. If the line set is already on CPU, no copy will be performed.", "open3d.t.geometry.PointCloud": "Transfer the point cloud to CPU. If the point cloud is already on CPU, no copy will be performed.", "open3d.t.geometry.RGBDImage": "Transfer the RGBD image to CPU. If the RGBD image is already on CPU, no copy will be performed.", "open3d.t.geometry.TriangleMesh": "Transfer the triangle mesh to CPU. If the triangle mesh is already on CPU, no copy will be performed.", "open3d.t.geometry.VoxelBlockGrid": "Transfer the voxel block grid to CPU. If the voxel block grid is already on CPU, no copy will be performed." }, "cuda": { "open3d.core.HashMap": "Transfer the hash map to a CUDA device. If the hash map is already on the specified CUDA device, no copy will be performed.", "open3d.core.HashSet": "Transfer the hash set to a CUDA device. If the hash set is already on the specified CUDA device, no copy will be performed.", "open3d.core.Tensor": "Transfer the tensor to a CUDA device. If the tensor is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.AxisAlignedBoundingBox": "Transfer the axis-aligned box to a CUDA device. If the axis-aligned box is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.Image": "Transfer the image to a CUDA device. If the image is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.LineSet": "Transfer the line set to a CUDA device. If the line set is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.PointCloud": "Transfer the point cloud to a CUDA device. If the point cloud is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.RGBDImage": "Transfer the RGBD image to a CUDA device. If the RGBD image is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.TriangleMesh": "Transfer the triangle mesh to a CUDA device. If the triangle mesh is already on the specified CUDA device, no copy will be performed.", "open3d.t.geometry.VoxelBlockGrid": "Transfer the voxel block grid to a CUDA device. If the voxel block grid is already on the specified CUDA device, no copy will be performed." }, "erase": { "open3d.core.HashMap": "Erase an array of keys stored in Tensors.", "open3d.core.HashSet": "Erase an array of keys stored in Tensors." }, "find": { "open3d.core.HashMap": "Find an array of keys stored in Tensors.", "open3d.core.HashSet": "Find an array of keys stored in Tensors." }, "key_tensor": { "open3d.core.HashMap": "Get the key tensor stored in the buffer.", "open3d.core.HashSet": "Get the key tensor stored in the buffer." }, "load": { "open3d.core.HashMap": "Load a hash map from a .npz file.", "open3d.core.HashSet": "Load a hash set from a .npz file.", "open3d.core.Tensor": "Load tensor from Numpy\u2019s npy format.", "open3d.ml.tf.vis.DataModel": "Load a pointcloud based on the name provided.", "open3d.ml.tf.vis.DatasetModel": "Check if data is not loaded, and then load the data.", "open3d.ml.tf.vis.Model": "If data is not loaded, then load the data.", "open3d.ml.torch.vis.DataModel": "Load a pointcloud based on the name provided.", "open3d.ml.torch.vis.DatasetModel": "Check if data is not loaded, and then load the data.", "open3d.ml.torch.vis.Model": "If data is not loaded, then load the data.", "open3d.t.geometry.VoxelBlockGrid": "Load a voxel block grid from a npz file." }, "reserve": { "open3d.core.HashMap": "Reserve the hash map given the capacity.", "open3d.core.HashSet": "Reserve the hash set given the capacity." }, "save": { "open3d.core.HashMap": "Save the hash map into a .npz file.", "open3d.core.HashSet": "Save the hash set into a .npz file.", "open3d.core.Tensor": "Save tensor to Numpy\u2019s npy format.", "open3d.t.geometry.VoxelBlockGrid": "Save the voxel block grid to a npz file." }, "size": { "open3d.core.HashMap": "Get the size of the hash map.", "open3d.core.HashSet": "Get the size of the hash set.", "open3d.geometry.Octree": "Outer bounding box edge size for the whole octree. A point is within bound iff origin <= point < origin + size.", "open3d.geometry.OctreeNodeInfo": "Size of the node.", "open3d.visualization.O3DVisualizer": "The size of the window in device pixels, including menubar (except on macOS)", "open3d.visualization.gui.Window": "The size of the window in device pixels, including menubar (except on macOS)" }, "to": { "open3d.core.HashMap": "Convert the hash map to a selected device.", "open3d.core.HashSet": "Convert the hash set to a selected device.", "open3d.core.Tensor": "Overloaded function.", "open3d.t.geometry.AxisAlignedBoundingBox": "Transfer the axis-aligned box to a specified device.", "open3d.t.geometry.Image": "Overloaded function.", "open3d.t.geometry.LineSet": "Transfer the line set to a specified device.", "open3d.t.geometry.PointCloud": "Transfer the point cloud to a specified device.", "open3d.t.geometry.RGBDImage": "Transfer the RGBDImage to a specified device.", "open3d.t.geometry.TriangleMesh": "Transfer the triangle mesh to a specified device.", "open3d.t.geometry.VoxelBlockGrid": "Transfer the voxel block grid to a specified device." }, "value_tensor": { "open3d.core.HashMap": "Overloaded function." }, "value_tensors": { "open3d.core.HashMap": "Get the list of value tensors stored in the buffer." }, "T": { "open3d.core.Tensor": "Transpose <=2-D tensor by swapping dimension 0 and 1.0-D and 1-D Tensor remains the same." }, "add": { "open3d.core.Tensor": "Overloaded function." }, "add_": { "open3d.core.Tensor": "Overloaded function." }, "all": { "open3d.core.Tensor": "Returns true if all elements in the tensor are true. Only works for boolean tensors." }, "allclose": { "open3d.core.Tensor": "Returns true if the two tensors are element-wise equal within a tolerance." }, "any": { "open3d.core.Tensor": "Returns true if any elements in the tensor are true. Only works for boolean tensors." }, "arange": { "open3d.core.Tensor": "Overloaded function." }, "clip": { "open3d.core.Tensor": "Overloaded function." }, "clip_": { "open3d.core.Tensor": "Overloaded function." }, "contiguous": { "open3d.core.Tensor": "Returns a contiguous tensor containing the same data in the same device. If the tensor is already contiguous, the same underlying memory will be used." }, "det": { "open3d.core.Tensor": "Compute the determinant of a 2D square tensor." }, "div": { "open3d.core.Tensor": "Overloaded function." }, "div_": { "open3d.core.Tensor": "Overloaded function." }, "empty": { "open3d.core.Tensor": "Create Tensor with a given shape." }, "eq": { "open3d.core.Tensor": "Overloaded function." }, "eq_": { "open3d.core.Tensor": "Overloaded function." }, "eye": { "open3d.core.Tensor": "Create an identity matrix of size n x n." }, "flatten": { "open3d.core.Tensor": "Flattens input by reshaping it into a one-dimensional tensor. If start_dim or end_dim are passed, only dimensions starting with start_dim and ending with end_dim are flattened. The order of elements in input is unchanged." }, "full": { "open3d.core.Tensor": "Overloaded function." }, "ge": { "open3d.core.Tensor": "Overloaded function." }, "ge_": { "open3d.core.Tensor": "Overloaded function." }, "gt": { "open3d.core.Tensor": "Overloaded function." }, "gt_": { "open3d.core.Tensor": "Overloaded function." }, "inv": { "open3d.core.Tensor": "Computes the matrix inverse of the square matrix self with LU factorization and returns the result." }, "is_contiguous": { "open3d.core.Tensor": "Returns True if the underlying memory buffer is contiguous." }, "isclose": { "open3d.core.Tensor": "Element-wise version of tensor.allclose." }, "issame": { "open3d.core.Tensor": "Returns true iff the tensor is the other tensor. This means that, the two tensors have the same underlying memory, device, dtype, shape, strides and etc." }, "item": { "open3d.core.Tensor": "Helper function to return the scalar value of a scalar tensor. The tensor must be 0 - dimensional (i.e. have an empty shape)." }, "le": { "open3d.core.Tensor": "Overloaded function." }, "le_": { "open3d.core.Tensor": "Overloaded function." }, "logical_and": { "open3d.core.Tensor": "Overloaded function." }, "logical_and_": { "open3d.core.Tensor": "Overloaded function." }, "logical_or": { "open3d.core.Tensor": "Overloaded function." }, "logical_or_": { "open3d.core.Tensor": "Overloaded function." }, "logical_xor": { "open3d.core.Tensor": "Overloaded function." }, "logical_xor_": { "open3d.core.Tensor": "Overloaded function." }, "lstsq": { "open3d.core.Tensor": "Solves the linear system AX = B with QR decomposition and returns X. A is a (m, n) matrix with m >= n." }, "lt": { "open3d.core.Tensor": "Overloaded function." }, "lt_": { "open3d.core.Tensor": "Overloaded function." }, "lu": { "open3d.core.Tensor": "Computes LU factorisation of the 2D square tensor, using A = P * L * U; where P is the permutation matrix, L is the lower-triangular matrix with diagonal elements as 1.0 and U is the upper-triangular matrix, and returns tuple (P, L, U)." }, "lu_ipiv": { "open3d.core.Tensor": "Computes LU factorisation of the 2D square tensor, using A = P * L * U; where P is the permutation matrix, L is the lower-triangular matrix with diagonal elements as 1.0 and U is the upper-triangular matrix, and returns tuple output tensor of shape {n,n} and ipiv tensor of shape {n}, where {n,n} is the shape of input tensor." }, "matmul": { "open3d.core.Tensor": "Computes matrix multiplication of a 2D tensor with another tensor of compatible shape." }, "mul": { "open3d.core.Tensor": "Overloaded function." }, "mul_": { "open3d.core.Tensor": "Overloaded function." }, "ne": { "open3d.core.Tensor": "Overloaded function." }, "ne_": { "open3d.core.Tensor": "Overloaded function." }, "nonzero": { "open3d.core.Tensor": "Find the indices of the elements that are non-zero." }, "ones": { "open3d.core.Tensor": "Create Tensor with a given shape." }, "reshape": { "open3d.core.Tensor": "Returns a tensor with the same data and number of elements as input, but with the specified shape. When possible, the returned tensor will be a view of input. Otherwise, it will be a copy." }, "solve": { "open3d.core.Tensor": "Solves the linear system AX = B with LU decomposition and returns X. A must be a square matrix." }, "sub": { "open3d.core.Tensor": "Overloaded function." }, "sub_": { "open3d.core.Tensor": "Overloaded function." }, "svd": { "open3d.core.Tensor": "Computes the matrix SVD decomposition \\ (A = U S V^T\\) and returns the result. Note \\ (V^T\\) (V transpose) is returned instead of \\ (V\\)." }, "tril": { "open3d.core.Tensor": "Returns the lower triangular matrix of the 2D tensor, above the given diagonal index. [The value of diagonal = col - row, therefore 0 is the main diagonal (row = col), and it shifts towards right for positive values (for diagonal = 1, col - row = 1), and towards left for negative values. The value of the diagonal parameter must be between [-m, n] where {m, n} is the shape of input tensor." }, "triu": { "open3d.core.Tensor": "Returns the upper triangular matrix of the 2D tensor, above the given diagonal index. [The value of diagonal = col - row, therefore 0 is the main diagonal (row = col), and it shifts towards right for positive values (for diagonal = 1, col - row = 1), and towards left for negative values. The value of the diagonal parameter must be between [-m, n] for a {m,n} shaped tensor." }, "triul": { "open3d.core.Tensor": "Returns the tuple of upper and lower triangular matrix of the 2D tensor, above and below the given diagonal index. The diagonal elements of lower triangular matrix are taken to be unity. [The value of diagonal = col - row, therefore 0 is the main diagonal (row = col), and it shifts towards right for positive values (for diagonal = 1, col - row = 1), and towards left for negative values. The value of the diagonal parameter must be between [-m, n] where {m, n} is the shape of input tensor." }, "zeros": { "open3d.core.Tensor": "Create Tensor with a given shape." }, "data_root": { "open3d.data.ArmadilloMesh": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.AvocadoModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.BedroomRGBDImages": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.BunnyMesh": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.CrateModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DamagedHelmetModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.Dataset": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoColoredICPPointClouds": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoCropPointCloud": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoCustomVisualization": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoFeatureMatchingPointClouds": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoICPPointClouds": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DemoPoseGraphOptimization": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.DownloadDataset": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.EaglePointCloud": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.FlightHelmetModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.JackJackL515Bag": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.JuneauImage": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.KnotMesh": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.LivingRoomPointClouds": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.LoungeRGBDImages": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.MetalTexture": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.MonkeyModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.OfficePointClouds": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.PCDPointCloud": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.PLYPointCloud": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.PaintedPlasterTexture": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.RedwoodIndoorLivingRoom1": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.RedwoodIndoorLivingRoom2": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.RedwoodIndoorOffice1": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.RedwoodIndoorOffice2": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleFountainRGBDImages": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleL515Bag": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleNYURGBDImage": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleRedwoodRGBDImages": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleSUNRGBDImage": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SampleTUMRGBDImage": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.SwordModel": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.TerrazzoTexture": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.TilesTexture": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.WoodFloorTexture": "Get data root directory. The data root is set at construction time or automatically determined.", "open3d.data.WoodTexture": "Get data root directory. The data root is set at construction time or automatically determined." }, "download_dir": { "open3d.data.ArmadilloMesh": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.AvocadoModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.BedroomRGBDImages": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.BunnyMesh": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.CrateModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DamagedHelmetModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.Dataset": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoColoredICPPointClouds": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoCropPointCloud": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoCustomVisualization": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoFeatureMatchingPointClouds": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoICPPointClouds": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DemoPoseGraphOptimization": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.DownloadDataset": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.EaglePointCloud": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.FlightHelmetModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.JackJackL515Bag": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.JuneauImage": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.KnotMesh": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.LivingRoomPointClouds": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.LoungeRGBDImages": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.MetalTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.MonkeyModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.OfficePointClouds": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.PCDPointCloud": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.PLYPointCloud": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.PaintedPlasterTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.RedwoodIndoorLivingRoom1": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.RedwoodIndoorLivingRoom2": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.RedwoodIndoorOffice1": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.RedwoodIndoorOffice2": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleFountainRGBDImages": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleL515Bag": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleNYURGBDImage": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleRedwoodRGBDImages": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleSUNRGBDImage": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SampleTUMRGBDImage": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.SwordModel": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.TerrazzoTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.TilesTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.WoodFloorTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}", "open3d.data.WoodTexture": "Get absolute path to download directory. i.e. ${data_root}/${download_prefix}/${prefix}" }, "extract_dir": { "open3d.data.ArmadilloMesh": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.AvocadoModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.BedroomRGBDImages": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.BunnyMesh": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.CrateModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DamagedHelmetModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.Dataset": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoColoredICPPointClouds": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoCropPointCloud": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoCustomVisualization": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoFeatureMatchingPointClouds": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoICPPointClouds": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DemoPoseGraphOptimization": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.DownloadDataset": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.EaglePointCloud": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.FlightHelmetModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.JackJackL515Bag": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.JuneauImage": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.KnotMesh": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.LivingRoomPointClouds": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.LoungeRGBDImages": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.MetalTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.MonkeyModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.OfficePointClouds": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.PCDPointCloud": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.PLYPointCloud": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.PaintedPlasterTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.RedwoodIndoorLivingRoom1": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.RedwoodIndoorLivingRoom2": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.RedwoodIndoorOffice1": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.RedwoodIndoorOffice2": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleFountainRGBDImages": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleL515Bag": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleNYURGBDImage": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleRedwoodRGBDImages": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleSUNRGBDImage": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SampleTUMRGBDImage": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.SwordModel": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.TerrazzoTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.TilesTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.WoodFloorTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}", "open3d.data.WoodTexture": "Get absolute path to extract directory. i.e. ${data_root}/${extract_prefix}/${prefix}" }, "path": { "open3d.data.ArmadilloMesh": "Path to the ArmadilloMesh.ply file.", "open3d.data.AvocadoModel": "Path to the AvocadoModel.glb file.", "open3d.data.BunnyMesh": "Path to the BunnyMesh.ply file.", "open3d.data.CrateModel": "Returns the crate model file.", "open3d.data.DamagedHelmetModel": "Path to the DamagedHelmetModel.glb file.", "open3d.data.EaglePointCloud": "Path to the EaglePointCloud.ply file.", "open3d.data.FlightHelmetModel": "Returns the FlightHelmet.gltf model file.", "open3d.data.JackJackL515Bag": "Path to the JackJackL515Bag.bag file.", "open3d.data.JuneauImage": "Path to the JuneauImage.jgp file.", "open3d.data.KnotMesh": "Path to the KnotMesh.ply file.", "open3d.data.MonkeyModel": "Returns the monkey model file.", "open3d.data.PCDPointCloud": "Path to the pcd format point cloud.", "open3d.data.PLYPointCloud": "Path to the ply format point cloud.", "open3d.data.SampleL515Bag": "Path to the SampleL515Bag.bag file.", "open3d.data.SwordModel": "Returns the sword model file." }, "prefix": { "open3d.data.ArmadilloMesh": "Get prefix for the dataset.", "open3d.data.AvocadoModel": "Get prefix for the dataset.", "open3d.data.BedroomRGBDImages": "Get prefix for the dataset.", "open3d.data.BunnyMesh": "Get prefix for the dataset.", "open3d.data.CrateModel": "Get prefix for the dataset.", "open3d.data.DamagedHelmetModel": "Get prefix for the dataset.", "open3d.data.Dataset": "Get prefix for the dataset.", "open3d.data.DemoColoredICPPointClouds": "Get prefix for the dataset.", "open3d.data.DemoCropPointCloud": "Get prefix for the dataset.", "open3d.data.DemoCustomVisualization": "Get prefix for the dataset.", "open3d.data.DemoFeatureMatchingPointClouds": "Get prefix for the dataset.", "open3d.data.DemoICPPointClouds": "Get prefix for the dataset.", "open3d.data.DemoPoseGraphOptimization": "Get prefix for the dataset.", "open3d.data.DownloadDataset": "Get prefix for the dataset.", "open3d.data.EaglePointCloud": "Get prefix for the dataset.", "open3d.data.FlightHelmetModel": "Get prefix for the dataset.", "open3d.data.JackJackL515Bag": "Get prefix for the dataset.", "open3d.data.JuneauImage": "Get prefix for the dataset.", "open3d.data.KnotMesh": "Get prefix for the dataset.", "open3d.data.LivingRoomPointClouds": "Get prefix for the dataset.", "open3d.data.LoungeRGBDImages": "Get prefix for the dataset.", "open3d.data.MetalTexture": "Get prefix for the dataset.", "open3d.data.MonkeyModel": "Get prefix for the dataset.", "open3d.data.OfficePointClouds": "Get prefix for the dataset.", "open3d.data.PCDPointCloud": "Get prefix for the dataset.", "open3d.data.PLYPointCloud": "Get prefix for the dataset.", "open3d.data.PaintedPlasterTexture": "Get prefix for the dataset.", "open3d.data.RedwoodIndoorLivingRoom1": "Get prefix for the dataset.", "open3d.data.RedwoodIndoorLivingRoom2": "Get prefix for the dataset.", "open3d.data.RedwoodIndoorOffice1": "Get prefix for the dataset.", "open3d.data.RedwoodIndoorOffice2": "Get prefix for the dataset.", "open3d.data.SampleFountainRGBDImages": "Get prefix for the dataset.", "open3d.data.SampleL515Bag": "Get prefix for the dataset.", "open3d.data.SampleNYURGBDImage": "Get prefix for the dataset.", "open3d.data.SampleRedwoodRGBDImages": "Get prefix for the dataset.", "open3d.data.SampleSUNRGBDImage": "Get prefix for the dataset.", "open3d.data.SampleTUMRGBDImage": "Get prefix for the dataset.", "open3d.data.SwordModel": "Get prefix for the dataset.", "open3d.data.TerrazzoTexture": "Get prefix for the dataset.", "open3d.data.TilesTexture": "Get prefix for the dataset.", "open3d.data.WoodFloorTexture": "Get prefix for the dataset.", "open3d.data.WoodTexture": "Get prefix for the dataset." }, "color_paths": { "open3d.data.BedroomRGBDImages": "List of paths to color image samples of size 21931. Use color_paths[0], color_paths[1] \u2026 color_paths[21930] to access the paths.", "open3d.data.LoungeRGBDImages": "List of paths to color image samples of size 3000. Use color_paths[0], color_paths[1] \u2026 color_paths[2999] to access the paths.", "open3d.data.RedwoodIndoorLivingRoom1": "List of paths to color images.", "open3d.data.RedwoodIndoorLivingRoom2": "List of paths to color images.", "open3d.data.RedwoodIndoorOffice1": "List of paths to color images.", "open3d.data.RedwoodIndoorOffice2": "List of paths to color images.", "open3d.data.SampleFountainRGBDImages": "List of paths to color image samples of size 33. Use color_paths[0], color_paths[1] \u2026 color_paths[32] to access the paths.", "open3d.data.SampleRedwoodRGBDImages": "List of paths to color image samples of size 5. Use color_paths[0], color_paths[1] \u2026 color_paths[4] to access the paths." }, "depth_paths": { "open3d.data.BedroomRGBDImages": "List of paths to depth image samples of size 21931. Use depth_paths[0], depth_paths[1] \u2026 depth_paths[21930] to access the paths.", "open3d.data.LoungeRGBDImages": "List of paths to depth image samples of size 3000. Use depth_paths[0], depth_paths[1] \u2026 depth_paths[2999] to access the paths.", "open3d.data.RedwoodIndoorLivingRoom1": "List of paths to depth images.", "open3d.data.RedwoodIndoorLivingRoom2": "List of paths to depth images.", "open3d.data.RedwoodIndoorOffice1": "List of paths to depth images.", "open3d.data.RedwoodIndoorOffice2": "List of paths to depth images.", "open3d.data.SampleFountainRGBDImages": "List of paths to depth image samples of size 33. Use depth_paths[0], depth_paths[1] \u2026 depth_paths[32] to access the paths.", "open3d.data.SampleRedwoodRGBDImages": "List of paths to depth image samples of size 5. Use depth_paths[0], depth_paths[1] \u2026 depth_paths[4] to access the paths." }, "reconstruction_path": { "open3d.data.BedroomRGBDImages": "Path to mesh reconstruction.", "open3d.data.LoungeRGBDImages": "Path to mesh reconstruction.", "open3d.data.SampleFountainRGBDImages": "Path to mesh reconstruction.", "open3d.data.SampleRedwoodRGBDImages": "Path to pointcloud reconstruction from TSDF." }, "trajectory_log_path": { "open3d.data.BedroomRGBDImages": "Path to camera trajectory log file trajectory.log.", "open3d.data.LoungeRGBDImages": "Path to camera trajectory log file trajectory.log.", "open3d.data.SampleRedwoodRGBDImages": "Path to camera trajectory log file trajectory.log." }, "path_map": { "open3d.data.CrateModel": "Returns the map of filename to path. Refer documentation page for available options.", "open3d.data.FlightHelmetModel": "Returns the map of filename to path. Refer documentation page for available options.", "open3d.data.MetalTexture": "Returns the map of filename to path.", "open3d.data.MonkeyModel": "Returns the map of filename to path. Refer documentation page for available options.", "open3d.data.PaintedPlasterTexture": "Returns the map of filename to path.", "open3d.data.SwordModel": "Returns the map of filename to path. Refer documentation page for available options.", "open3d.data.TerrazzoTexture": "Returns the map of filename to path.", "open3d.data.TilesTexture": "Returns the map of filename to path.", "open3d.data.WoodFloorTexture": "Returns the map of filename to path.", "open3d.data.WoodTexture": "Returns the map of filename to path." }, "extract_in_subdir": { "open3d.data.DataDescriptor": "Subdirectory to extract the file. If empty, the file will be extracted in the root extract directory of the dataset." }, "md5": { "open3d.data.DataDescriptor": "MD5 hash of the data file." }, "urls": { "open3d.data.DataDescriptor": "URL to download the data file." }, "paths": { "open3d.data.DemoColoredICPPointClouds": "List of 2 point cloud paths. Use paths[0], and paths[1], to access the paths.", "open3d.data.DemoICPPointClouds": "List of 3 point cloud paths. Use paths[0], paths[1], and paths[2] to access the paths.", "open3d.data.LivingRoomPointClouds": "List of paths to ply point-cloud fragments of size 57. Use paths[0], paths[1] \u2026 paths[56] to access the paths.", "open3d.data.OfficePointClouds": "List of paths to ply point-cloud fragments of size 53. Use paths[0], paths[1] \u2026 paths[52] to access the paths." }, "cropped_json_path": { "open3d.data.DemoCropPointCloud": "Path to the saved selected polygon volume file." }, "point_cloud_path": { "open3d.data.DemoCropPointCloud": "Path to the example point cloud.", "open3d.data.DemoCustomVisualization": "Returns path to the point cloud (ply).", "open3d.data.RedwoodIndoorLivingRoom1": "Path to the point cloud.", "open3d.data.RedwoodIndoorLivingRoom2": "Path to the point cloud.", "open3d.data.RedwoodIndoorOffice1": "Path to the point cloud.", "open3d.data.RedwoodIndoorOffice2": "Path to the point cloud." }, "camera_trajectory_path": { "open3d.data.DemoCustomVisualization": "Returns path to the camera_trajectory.json." }, "render_option_path": { "open3d.data.DemoCustomVisualization": "Returns path to the renderoption.json." }, "fpfh_feature_paths": { "open3d.data.DemoFeatureMatchingPointClouds": "List of 2 saved FPFH feature binary of the respective point cloud paths. Use fpfh_feature_paths[0], and fpfh_feature_paths[1], to access the paths." }, "l32d_feature_paths": { "open3d.data.DemoFeatureMatchingPointClouds": "List of 2 saved L32D feature binary of the respective point cloud paths. Use l32d_feature_paths[0], and l32d_feature_paths[1], to access the paths." }, "point_cloud_paths": { "open3d.data.DemoFeatureMatchingPointClouds": "List of 2 point cloud paths. Use point_cloud_paths[0], and point_cloud_paths[1], to access the paths." }, "transformation_log_path": { "open3d.data.DemoICPPointClouds": "Path to the transformation metadata log file, containing transformation between frame 0 and 1, and frame 1 and 2." }, "pose_graph_fragment_path": { "open3d.data.DemoPoseGraphOptimization": "Path to example global pose graph (json)." }, "pose_graph_global_path": { "open3d.data.DemoPoseGraphOptimization": "Path to example fragment pose graph (json)." }, "albedo_texture_path": { "open3d.data.MetalTexture": "Path to albedo color texture image.", "open3d.data.PaintedPlasterTexture": "Path to albedo color texture image.", "open3d.data.TerrazzoTexture": "Path to albedo color texture image.", "open3d.data.TilesTexture": "Path to albedo color texture image.", "open3d.data.WoodFloorTexture": "Path to albedo color texture image.", "open3d.data.WoodTexture": "Path to albedo color texture image." }, "metallic_texture_path": { "open3d.data.MetalTexture": "Path to metallic texture image." }, "normal_texture_path": { "open3d.data.MetalTexture": "Path to normal texture image.", "open3d.data.PaintedPlasterTexture": "Path to normal texture image.", "open3d.data.TerrazzoTexture": "Path to normal texture image.", "open3d.data.TilesTexture": "Path to normal texture image.", "open3d.data.WoodFloorTexture": "Path to normal texture image.", "open3d.data.WoodTexture": "Path to normal texture image." }, "roughness_texture_path": { "open3d.data.MetalTexture": "Path to roughness texture image.", "open3d.data.PaintedPlasterTexture": "Path to roughness texture image.", "open3d.data.TerrazzoTexture": "Path to roughness texture image.", "open3d.data.TilesTexture": "Path to roughness texture image.", "open3d.data.WoodFloorTexture": "Path to roughness texture image.", "open3d.data.WoodTexture": "Path to roughness texture image." }, "noise_model_path": { "open3d.data.RedwoodIndoorLivingRoom1": "Path to the noise model file.", "open3d.data.RedwoodIndoorLivingRoom2": "Path to the noise model file.", "open3d.data.RedwoodIndoorOffice1": "Path to the noise model file.", "open3d.data.RedwoodIndoorOffice2": "Path to the noise model file." }, "noisy_depth_paths": { "open3d.data.RedwoodIndoorLivingRoom1": "List of paths to noisy depth images.", "open3d.data.RedwoodIndoorLivingRoom2": "List of paths to noisy depth images.", "open3d.data.RedwoodIndoorOffice1": "List of paths to noisy depth images.", "open3d.data.RedwoodIndoorOffice2": "List of paths to noisy depth images." }, "oni_path": { "open3d.data.RedwoodIndoorLivingRoom1": "Path to the oni file.", "open3d.data.RedwoodIndoorLivingRoom2": "Path to the oni file.", "open3d.data.RedwoodIndoorOffice1": "Path to the oni file.", "open3d.data.RedwoodIndoorOffice2": "Path to the oni file." }, "trajectory_path": { "open3d.data.RedwoodIndoorLivingRoom1": "Path to the trajectory file.", "open3d.data.RedwoodIndoorLivingRoom2": "Path to the trajectory file.", "open3d.data.RedwoodIndoorOffice1": "Path to the trajectory file.", "open3d.data.RedwoodIndoorOffice2": "Path to the trajectory file." }, "keyframe_poses_log_path": { "open3d.data.SampleFountainRGBDImages": "Path to camera poses at key frames log file key.log." }, "color_path": { "open3d.data.SampleNYURGBDImage": "Path to color image sample.", "open3d.data.SampleSUNRGBDImage": "Path to color image sample.", "open3d.data.SampleTUMRGBDImage": "Path to color image sample." }, "depth_path": { "open3d.data.SampleNYURGBDImage": "Path to depth image sample.", "open3d.data.SampleSUNRGBDImage": "Path to depth image sample.", "open3d.data.SampleTUMRGBDImage": "Path to depth image sample." }, "camera_intrinsic_path": { "open3d.data.SampleRedwoodRGBDImages": "Path to pinhole camera intrinsic (json)." }, "odometry_log_path": { "open3d.data.SampleRedwoodRGBDImages": "Path to camera odometry log file odometry.log." }, "rgbd_match_path": { "open3d.data.SampleRedwoodRGBDImages": "Path to color and depth image match file rgbd.match." }, "create_from_points": { "open3d.geometry.AxisAlignedBoundingBox": "Creates the bounding box that encloses the set of points.", "open3d.geometry.OrientedBoundingBox": "Creates the oriented bounding box that encloses the set of points.", "open3d.t.geometry.AxisAlignedBoundingBox": "Creates the axis-aligned box that encloses the set of points." }, "dimension": { "open3d.geometry.AxisAlignedBoundingBox": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.Geometry": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.Geometry2D": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.Geometry3D": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.Image": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.LineSet": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.MeshBase": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.Octree": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.OrientedBoundingBox": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.PointCloud": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.RGBDImage": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.TetraMesh": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.TriangleMesh": "Returns whether the geometry is 2D or 3D.", "open3d.geometry.VoxelGrid": "Returns whether the geometry is 2D or 3D.", "open3d.pipelines.registration.Feature": "Returns feature dimensions per point." }, "get_axis_aligned_bounding_box": { "open3d.geometry.AxisAlignedBoundingBox": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.Geometry3D": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.LineSet": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.MeshBase": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.Octree": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.OrientedBoundingBox": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.PointCloud": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.TetraMesh": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.TriangleMesh": "Returns an axis-aligned bounding box of the geometry.", "open3d.geometry.VoxelGrid": "Returns an axis-aligned bounding box of the geometry.", "open3d.t.geometry.LineSet": "Create an axis-aligned bounding box from point attribute \u2018positions\u2019.", "open3d.t.geometry.PointCloud": "Create an axis-aligned bounding box from attribute \u2018positions\u2019.", "open3d.t.geometry.TriangleMesh": "Create an axis-aligned bounding box from vertex attribute \u2018positions\u2019." }, "get_box_points": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the eight points that define the bounding box.", "open3d.geometry.OrientedBoundingBox": "Returns the eight points that define the bounding box.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the eight points that define the bounding box. The Return tensor has shape {8, 3} and data type of float32." }, "get_center": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the center of the geometry coordinates.", "open3d.geometry.Geometry3D": "Returns the center of the geometry coordinates.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns the center of the geometry coordinates.", "open3d.geometry.LineSet": "Returns the center of the geometry coordinates.", "open3d.geometry.MeshBase": "Returns the center of the geometry coordinates.", "open3d.geometry.Octree": "Returns the center of the geometry coordinates.", "open3d.geometry.OrientedBoundingBox": "Returns the center of the geometry coordinates.", "open3d.geometry.PointCloud": "Returns the center of the geometry coordinates.", "open3d.geometry.TetraMesh": "Returns the center of the geometry coordinates.", "open3d.geometry.TriangleMesh": "Returns the center of the geometry coordinates.", "open3d.geometry.VoxelGrid": "Returns the center of the geometry coordinates.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the center for box coordinates.", "open3d.t.geometry.LineSet": "Returns the center for point coordinates.", "open3d.t.geometry.PointCloud": "Returns the center for point coordinates.", "open3d.t.geometry.TriangleMesh": "Returns the center for point coordinates." }, "get_extent": { "open3d.geometry.AxisAlignedBoundingBox": "Get the extent/length of the bounding box in x, y, and z dimension.", "open3d.t.geometry.AxisAlignedBoundingBox": "Get the extent/length of the bounding box in x, y, and z dimension." }, "get_geometry_type": { "open3d.geometry.AxisAlignedBoundingBox": "Returns one of registered geometry types.", "open3d.geometry.Geometry": "Returns one of registered geometry types.", "open3d.geometry.Geometry2D": "Returns one of registered geometry types.", "open3d.geometry.Geometry3D": "Returns one of registered geometry types.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns one of registered geometry types.", "open3d.geometry.Image": "Returns one of registered geometry types.", "open3d.geometry.LineSet": "Returns one of registered geometry types.", "open3d.geometry.MeshBase": "Returns one of registered geometry types.", "open3d.geometry.Octree": "Returns one of registered geometry types.", "open3d.geometry.OrientedBoundingBox": "Returns one of registered geometry types.", "open3d.geometry.PointCloud": "Returns one of registered geometry types.", "open3d.geometry.RGBDImage": "Returns one of registered geometry types.", "open3d.geometry.TetraMesh": "Returns one of registered geometry types.", "open3d.geometry.TriangleMesh": "Returns one of registered geometry types.", "open3d.geometry.VoxelGrid": "Returns one of registered geometry types." }, "get_half_extent": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the half extent of the bounding box.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the half extent of the bounding box." }, "get_max_bound": { "open3d.geometry.AxisAlignedBoundingBox": "Returns max bounds for geometry coordinates.", "open3d.geometry.Geometry2D": "Returns max bounds for geometry coordinates.", "open3d.geometry.Geometry3D": "Returns max bounds for geometry coordinates.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns max bounds for geometry coordinates.", "open3d.geometry.Image": "Returns max bounds for geometry coordinates.", "open3d.geometry.LineSet": "Returns max bounds for geometry coordinates.", "open3d.geometry.MeshBase": "Returns max bounds for geometry coordinates.", "open3d.geometry.Octree": "Returns max bounds for geometry coordinates.", "open3d.geometry.OrientedBoundingBox": "Returns max bounds for geometry coordinates.", "open3d.geometry.PointCloud": "Returns max bounds for geometry coordinates.", "open3d.geometry.RGBDImage": "Returns max bounds for geometry coordinates.", "open3d.geometry.TetraMesh": "Returns max bounds for geometry coordinates.", "open3d.geometry.TriangleMesh": "Returns max bounds for geometry coordinates.", "open3d.geometry.VoxelGrid": "Returns max bounds for geometry coordinates.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the max bound for box coordinates.", "open3d.t.geometry.Image": "Compute max 2D coordinates for the data ({rows, cols}).", "open3d.t.geometry.LineSet": "Returns the max bound for point coordinates.", "open3d.t.geometry.PointCloud": "Returns the max bound for point coordinates.", "open3d.t.geometry.RGBDImage": "Compute max 2D coordinates for the data.", "open3d.t.geometry.TriangleMesh": "Returns the max bound for point coordinates." }, "get_max_extent": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the maximum extent, i.e. the maximum of X, Y and Z axis", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the maximum extent, i.e. the maximum of X, Y and Z axis\u2019s extents." }, "get_min_bound": { "open3d.geometry.AxisAlignedBoundingBox": "Returns min bounds for geometry coordinates.", "open3d.geometry.Geometry2D": "Returns min bounds for geometry coordinates.", "open3d.geometry.Geometry3D": "Returns min bounds for geometry coordinates.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns min bounds for geometry coordinates.", "open3d.geometry.Image": "Returns min bounds for geometry coordinates.", "open3d.geometry.LineSet": "Returns min bounds for geometry coordinates.", "open3d.geometry.MeshBase": "Returns min bounds for geometry coordinates.", "open3d.geometry.Octree": "Returns min bounds for geometry coordinates.", "open3d.geometry.OrientedBoundingBox": "Returns min bounds for geometry coordinates.", "open3d.geometry.PointCloud": "Returns min bounds for geometry coordinates.", "open3d.geometry.RGBDImage": "Returns min bounds for geometry coordinates.", "open3d.geometry.TetraMesh": "Returns min bounds for geometry coordinates.", "open3d.geometry.TriangleMesh": "Returns min bounds for geometry coordinates.", "open3d.geometry.VoxelGrid": "Returns min bounds for geometry coordinates.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the min bound for box coordinates.", "open3d.t.geometry.Image": "Compute min 2D coordinates for the data (always {0, 0}).", "open3d.t.geometry.LineSet": "Returns the min bound for point coordinates.", "open3d.t.geometry.PointCloud": "Returns the min bound for point coordinates.", "open3d.t.geometry.RGBDImage": "Compute min 2D coordinates for the data (always {0, 0}).", "open3d.t.geometry.TriangleMesh": "Returns the min bound for point coordinates." }, "get_oriented_bounding_box": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the oriented bounding box for the geometry.", "open3d.geometry.Geometry3D": "Returns the oriented bounding box for the geometry.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns the oriented bounding box for the geometry.", "open3d.geometry.LineSet": "Returns the oriented bounding box for the geometry.", "open3d.geometry.MeshBase": "Returns the oriented bounding box for the geometry.", "open3d.geometry.Octree": "Returns the oriented bounding box for the geometry.", "open3d.geometry.OrientedBoundingBox": "Returns the oriented bounding box for the geometry.", "open3d.geometry.PointCloud": "Returns the oriented bounding box for the geometry.", "open3d.geometry.TetraMesh": "Returns the oriented bounding box for the geometry.", "open3d.geometry.TriangleMesh": "Returns the oriented bounding box for the geometry.", "open3d.geometry.VoxelGrid": "Returns the oriented bounding box for the geometry." }, "get_point_indices_within_bounding_box": { "open3d.geometry.AxisAlignedBoundingBox": "Return indices to points that are within the bounding box.", "open3d.geometry.OrientedBoundingBox": "Return indices to points that are within the bounding box.", "open3d.t.geometry.AxisAlignedBoundingBox": "Indices to points that are within the bounding box." }, "get_print_info": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the 3D dimensions of the bounding box in string format." }, "is_empty": { "open3d.geometry.AxisAlignedBoundingBox": "Returns True iff the geometry is empty.", "open3d.geometry.Geometry": "Returns True iff the geometry is empty.", "open3d.geometry.Geometry2D": "Returns True iff the geometry is empty.", "open3d.geometry.Geometry3D": "Returns True iff the geometry is empty.", "open3d.geometry.HalfEdgeTriangleMesh": "Returns True iff the geometry is empty.", "open3d.geometry.Image": "Returns True iff the geometry is empty.", "open3d.geometry.LineSet": "Returns True iff the geometry is empty.", "open3d.geometry.MeshBase": "Returns True iff the geometry is empty.", "open3d.geometry.Octree": "Returns True iff the geometry is empty.", "open3d.geometry.OrientedBoundingBox": "Returns True iff the geometry is empty.", "open3d.geometry.PointCloud": "Returns True iff the geometry is empty.", "open3d.geometry.RGBDImage": "Returns True iff the geometry is empty.", "open3d.geometry.TetraMesh": "Returns True iff the geometry is empty.", "open3d.geometry.TriangleMesh": "Returns True iff the geometry is empty.", "open3d.geometry.VoxelGrid": "Returns True iff the geometry is empty.", "open3d.ml.tf.vis.Visualizer.LabelLUTEdit": "Checks if the look-up table is empty.", "open3d.ml.torch.vis.Visualizer.LabelLUTEdit": "Checks if the look-up table is empty.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns True iff the geometry is empty.", "open3d.t.geometry.Geometry": "Returns True iff the geometry is empty.", "open3d.t.geometry.Image": "Is any data stored?", "open3d.t.geometry.LineSet": "Returns True iff the geometry is empty.", "open3d.t.geometry.PointCloud": "Returns True iff the geometry is empty.", "open3d.t.geometry.RGBDImage": "Is any data stored?", "open3d.t.geometry.TriangleMesh": "Returns True iff the geometry is empty." }, "rotate": { "open3d.geometry.AxisAlignedBoundingBox": "Overloaded function.", "open3d.geometry.Geometry3D": "Overloaded function.", "open3d.geometry.HalfEdgeTriangleMesh": "Overloaded function.", "open3d.geometry.LineSet": "Overloaded function.", "open3d.geometry.MeshBase": "Overloaded function.", "open3d.geometry.Octree": "Overloaded function.", "open3d.geometry.OrientedBoundingBox": "Overloaded function.", "open3d.geometry.PointCloud": "Overloaded function.", "open3d.geometry.TetraMesh": "Overloaded function.", "open3d.geometry.TriangleMesh": "Overloaded function.", "open3d.geometry.VoxelGrid": "Overloaded function.", "open3d.ml.tf.vis.deque": "Rotate the deque n steps to the right (default n=1). If n is negative, rotates left.", "open3d.ml.torch.vis.deque": "Rotate the deque n steps to the right (default n=1). If n is negative, rotates left.", "open3d.t.geometry.LineSet": "Rotate points and lines. Custom attributes (e.g. point normals) are not rotated.", "open3d.t.geometry.PointCloud": "Rotate points and normals (if exist).", "open3d.t.geometry.TriangleMesh": "Rotate points and normals (if exist).", "open3d.visualization.ViewControl": "Function to process rotation" }, "scale": { "open3d.geometry.AxisAlignedBoundingBox": "Overloaded function.", "open3d.geometry.Geometry3D": "Overloaded function.", "open3d.geometry.HalfEdgeTriangleMesh": "Overloaded function.", "open3d.geometry.LineSet": "Overloaded function.", "open3d.geometry.MeshBase": "Overloaded function.", "open3d.geometry.Octree": "Overloaded function.", "open3d.geometry.OrientedBoundingBox": "Overloaded function.", "open3d.geometry.PointCloud": "Overloaded function.", "open3d.geometry.TetraMesh": "Overloaded function.", "open3d.geometry.TriangleMesh": "Overloaded function.", "open3d.geometry.VoxelGrid": "Overloaded function.", "open3d.t.geometry.AxisAlignedBoundingBox": "Scale the axis-aligned box. If f$mif$ is the min_bound and f$maf$ is the max_bound of the axis aligned bounding box, and f$sf$ and f$cf$ are the provided scaling factor and center respectively, then the new min_bound and max_bound are given by f$mi = c + s (mi - c)f$ and f$ma = c + s (ma - c)f$.", "open3d.t.geometry.LineSet": "Scale points and lines. Custom attributes are not scaled.", "open3d.t.geometry.PointCloud": "Scale points.", "open3d.t.geometry.TriangleMesh": "Scale points.", "open3d.visualization.ViewControl": "Function to process scaling", "open3d.visualization.gui.Label3D": "large values of scale may result in blurry text as the underlying font is not resized." }, "transform": { "open3d.geometry.AxisAlignedBoundingBox": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.Geometry3D": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.HalfEdgeTriangleMesh": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.LineSet": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.MeshBase": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.Octree": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.OrientedBoundingBox": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.PointCloud": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.TetraMesh": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.TriangleMesh": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.geometry.VoxelGrid": "Apply transformation (4x4 matrix) to the geometry coordinates.", "open3d.ml.tf.models.KPFCNN": "[None, 3], [None, 3], [None], [None]", "open3d.ml.tf.models.PVCNN": "Transform function for the point cloud and features.", "open3d.ml.tf.models.PointPillars": "Transform function for the point cloud and features.", "open3d.ml.tf.models.PointRCNN": "Transform function for the point cloud and features.", "open3d.ml.tf.models.PointTransformer": "Transform function for the point cloud and features.", "open3d.ml.tf.models.RandLANet": "Transform function for the point cloud and features.", "open3d.ml.tf.models.SparseConvUnet": "Transform function for the point cloud and features.", "open3d.ml.torch.models.KPFCNN": "Transform function for the point cloud and features.", "open3d.ml.torch.models.PVCNN": "Transform function for the point cloud and features.", "open3d.ml.torch.models.PointPillars": "Transform function for the point cloud and features.", "open3d.ml.torch.models.PointRCNN": "Transform function for the point cloud and features.", "open3d.ml.torch.models.PointTransformer": "Transform function for the point cloud and features.", "open3d.ml.torch.models.RandLANet": "Transform function for the point cloud and features.", "open3d.ml.torch.models.SparseConvUnet": "Transform function for the point cloud and features.", "open3d.t.geometry.LineSet": "Transforms the points and lines. Custom attributes (e.g. point normals) are not transformed. Extracts R, t from the transformation as:", "open3d.t.geometry.PointCloud": "Transforms the points and normals (if exist).", "open3d.t.geometry.TriangleMesh": "Transforms the points and normals (if exist)." }, "translate": { "open3d.geometry.AxisAlignedBoundingBox": "Apply translation to the geometry coordinates.", "open3d.geometry.Geometry3D": "Apply translation to the geometry coordinates.", "open3d.geometry.HalfEdgeTriangleMesh": "Apply translation to the geometry coordinates.", "open3d.geometry.LineSet": "Apply translation to the geometry coordinates.", "open3d.geometry.MeshBase": "Apply translation to the geometry coordinates.", "open3d.geometry.Octree": "Apply translation to the geometry coordinates.", "open3d.geometry.OrientedBoundingBox": "Apply translation to the geometry coordinates.", "open3d.geometry.PointCloud": "Apply translation to the geometry coordinates.", "open3d.geometry.TetraMesh": "Apply translation to the geometry coordinates.", "open3d.geometry.TriangleMesh": "Apply translation to the geometry coordinates.", "open3d.geometry.VoxelGrid": "Apply translation to the geometry coordinates.", "open3d.t.geometry.AxisAlignedBoundingBox": "Translate the axis-aligned box by the given translation. If relative is true, the translation is applied to the current min and max bound. If relative is false, the translation is applied to make the box\u2019s center at the given translation.", "open3d.t.geometry.LineSet": "Translates points and lines of the LineSet.", "open3d.t.geometry.PointCloud": "Translates points.", "open3d.t.geometry.TriangleMesh": "Translates points.", "open3d.visualization.ViewControl": "Function to process translation" }, "volume": { "open3d.geometry.AxisAlignedBoundingBox": "Returns the volume of the bounding box.", "open3d.geometry.OrientedBoundingBox": "Returns the volume of the bounding box.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the volume of the bounding box." }, "color": { "open3d.geometry.AxisAlignedBoundingBox": "float64 array of shape (3, )", "open3d.geometry.OctreeColorLeafNode": "Color of the node.", "open3d.geometry.OctreePointColorLeafNode": "Color of the node.", "open3d.geometry.OrientedBoundingBox": "float64 array of shape (3, )", "open3d.geometry.RGBDImage": "The color image.", "open3d.geometry.Voxel": "Color of the voxel.", "open3d.t.geometry.RGBDImage": "The color image.", "open3d.visualization.gui.Label3D": "The color of the text (gui.Color)", "open3d.visualization.rendering.Gradient.Point": "[R, G, B, A]. Color values must be in [0.0, 1.0]" }, "max_bound": { "open3d.geometry.AxisAlignedBoundingBox": "float64 array of shape (3, )" }, "min_bound": { "open3d.geometry.AxisAlignedBoundingBox": "float64 array of shape (3, )" }, "is_boundary": { "open3d.geometry.HalfEdge": "Returns True iff the half edge is the boundary (has not twin, i.e. twin index == -1)." }, "next": { "open3d.geometry.HalfEdge": "Index of the next HalfEdge in the same triangle." }, "triangle_index": { "open3d.geometry.HalfEdge": "Index of the triangle containing this half edge" }, "twin": { "open3d.geometry.HalfEdge": "Index of the twin HalfEdge" }, "vertex_indices": { "open3d.geometry.HalfEdge": "Index of the ordered vertices forming this half edge" }, "boundary_half_edges_from_vertex": { "open3d.geometry.HalfEdgeTriangleMesh": "Query manifold boundary half edges from a starting vertex. If query vertex is not on boundary, empty vector will be returned." }, "boundary_vertices_from_vertex": { "open3d.geometry.HalfEdgeTriangleMesh": "open3d.utility.IntVector" }, "compute_convex_hull": { "open3d.geometry.HalfEdgeTriangleMesh": "Computes the convex hull of the triangle mesh.", "open3d.geometry.MeshBase": "Computes the convex hull of the triangle mesh.", "open3d.geometry.PointCloud": "Computes the convex hull of the point cloud.", "open3d.geometry.TetraMesh": "Computes the convex hull of the triangle mesh.", "open3d.geometry.TriangleMesh": "Computes the convex hull of the triangle mesh.", "open3d.t.geometry.PointCloud": "Compute the convex hull of a triangle mesh using qhull. This runs on the CPU.", "open3d.t.geometry.TriangleMesh": "Compute the convex hull of a point cloud using qhull. This runs on the CPU." }, "create_from_triangle_mesh": { "open3d.geometry.HalfEdgeTriangleMesh": "Convert HalfEdgeTriangleMesh from TriangleMesh. Throws exception if the input mesh is not manifolds", "open3d.geometry.LineSet": "Factory function to create a LineSet from edges of a triangle mesh.", "open3d.geometry.VoxelGrid": "Creates a VoxelGrid from a given TriangleMesh. No color information is converted. The bounds of the created VoxelGrid are computed from the TriangleMesh." }, "get_boundaries": { "open3d.geometry.HalfEdgeTriangleMesh": "Returns a vector of boundaries. A boundary is a vector of vertices." }, "has_half_edges": { "open3d.geometry.HalfEdgeTriangleMesh": "Returns True if half-edges have already been computed." }, "has_vertex_colors": { "open3d.geometry.HalfEdgeTriangleMesh": "Returns True if the mesh contains vertex colors.", "open3d.geometry.MeshBase": "Returns True if the mesh contains vertex colors.", "open3d.geometry.TetraMesh": "Returns True if the mesh contains vertex colors.", "open3d.geometry.TriangleMesh": "Returns True if the mesh contains vertex colors." }, "has_vertex_normals": { "open3d.geometry.HalfEdgeTriangleMesh": "Returns True if the mesh contains vertex normals.", "open3d.geometry.MeshBase": "Returns True if the mesh contains vertex normals.", "open3d.geometry.TetraMesh": "Returns True if the mesh contains vertex normals.", "open3d.geometry.TriangleMesh": "Returns True if the mesh contains vertex normals." }, "has_vertices": { "open3d.geometry.HalfEdgeTriangleMesh": "Returns True if the mesh contains vertices.", "open3d.geometry.MeshBase": "Returns True if the mesh contains vertices.", "open3d.geometry.TetraMesh": "Returns True if the mesh contains vertices.", "open3d.geometry.TriangleMesh": "Returns True if the mesh contains vertices." }, "normalize_normals": { "open3d.geometry.HalfEdgeTriangleMesh": "Normalize vertex normals to length 1.", "open3d.geometry.MeshBase": "Normalize vertex normals to length 1.", "open3d.geometry.PointCloud": "Normalize point normals to length 1.", "open3d.geometry.TetraMesh": "Normalize vertex normals to length 1.", "open3d.geometry.TriangleMesh": "Normalize both triangle normals and vertex normals to length 1." }, "paint_uniform_color": { "open3d.geometry.HalfEdgeTriangleMesh": "Assigns each vertex in the MeshBase the same color.", "open3d.geometry.LineSet": "Assigns each line in the line set the same color.", "open3d.geometry.MeshBase": "Assigns each vertex in the MeshBase the same color.", "open3d.geometry.PointCloud": "Assigns each point in the PointCloud the same color.", "open3d.geometry.TetraMesh": "Assigns each vertex in the MeshBase the same color.", "open3d.geometry.TriangleMesh": "Assigns each vertex in the TriangleMesh the same color.", "open3d.t.geometry.PointCloud": "Assigns uniform color to the point cloud." }, "half_edges": { "open3d.geometry.HalfEdgeTriangleMesh": "List of HalfEdge in the mesh" }, "ordered_half_edge_from_vertex": { "open3d.geometry.HalfEdgeTriangleMesh": "Counter-clockwise ordered half-edges started from each vertex" }, "triangle_normals": { "open3d.geometry.HalfEdgeTriangleMesh": "Triangle normals.", "open3d.geometry.TriangleMesh": "Triangle normals." }, "triangles": { "open3d.geometry.HalfEdgeTriangleMesh": "List of triangles denoted by the index of points forming the triangle.", "open3d.geometry.TriangleMesh": "List of triangles denoted by the index of points forming the triangle." }, "vertex_colors": { "open3d.geometry.HalfEdgeTriangleMesh": "RGB colors of vertices.", "open3d.geometry.MeshBase": "RGB colors of vertices.", "open3d.geometry.TetraMesh": "RGB colors of vertices.", "open3d.geometry.TriangleMesh": "RGB colors of vertices." }, "vertex_normals": { "open3d.geometry.HalfEdgeTriangleMesh": "Vertex normals.", "open3d.geometry.MeshBase": "Vertex normals.", "open3d.geometry.TetraMesh": "Vertex normals.", "open3d.geometry.TriangleMesh": "Vertex normals." }, "vertices": { "open3d.geometry.HalfEdgeTriangleMesh": "Vertex coordinates.", "open3d.geometry.MeshBase": "Vertex coordinates.", "open3d.geometry.TetraMesh": "Vertex coordinates.", "open3d.geometry.TriangleMesh": "Vertex coordinates." }, "create_pyramid": { "open3d.geometry.Image": "Function to create ImagePyramid" }, "filter": { "open3d.geometry.Image": "Function to filter Image", "open3d.t.geometry.Image": "Return a new image after filtering with the given kernel." }, "filter_pyramid": { "open3d.geometry.Image": "Function to filter ImagePyramid" }, "flip_horizontal": { "open3d.geometry.Image": "Function to flip image horizontally (from left to right)" }, "flip_vertical": { "open3d.geometry.Image": "Function to flip image vertically (upside down)" }, "search_hybrid_vector_3d": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[3, 1]]) \u2013 The input query point." }, "search_hybrid_vector_xd": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[m, 1]]) \u2013 The input query point." }, "search_knn_vector_3d": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[3, 1]]) \u2013 The input query point." }, "search_knn_vector_xd": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[m, 1]]) \u2013 The input query point." }, "search_radius_vector_3d": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[3, 1]]) \u2013 The input query point." }, "search_radius_vector_xd": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[m, 1]]) \u2013 The input query point." }, "search_vector_3d": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[3, 1]]) \u2013 The input query point." }, "search_vector_xd": { "open3d.geometry.KDTreeFlann": "query (numpy.ndarray[numpy.float64[m, 1]]) \u2013 The input query point." }, "set_feature": { "open3d.geometry.KDTreeFlann": "Sets the data for the KDTree from the feature data." }, "set_geometry": { "open3d.geometry.KDTreeFlann": "Sets the data for the KDTree from geometry." }, "set_matrix_data": { "open3d.geometry.KDTreeFlann": "Sets the data for the KDTree from a matrix." }, "get_search_type": { "open3d.geometry.KDTreeSearchParam": "Get the search type (KNN, Radius, Hybrid) for the search parameter.", "open3d.geometry.KDTreeSearchParamHybrid": "Get the search type (KNN, Radius, Hybrid) for the search parameter.", "open3d.geometry.KDTreeSearchParamKNN": "Get the search type (KNN, Radius, Hybrid) for the search parameter.", "open3d.geometry.KDTreeSearchParamRadius": "Get the search type (KNN, Radius, Hybrid) for the search parameter." }, "max_nn": { "open3d.geometry.KDTreeSearchParamHybrid": "At maximum, max_nn neighbors will be searched." }, "radius": { "open3d.geometry.KDTreeSearchParamHybrid": "Search radius.", "open3d.geometry.KDTreeSearchParamRadius": "Search radius." }, "knn": { "open3d.geometry.KDTreeSearchParamKNN": "Number of the neighbors that will be searched." }, "create_camera_visualization": { "open3d.geometry.LineSet": "Overloaded function." }, "create_from_axis_aligned_bounding_box": { "open3d.geometry.LineSet": "Factory function to create a LineSet from an AxisAlignedBoundingBox.", "open3d.geometry.OrientedBoundingBox": "Returns an oriented bounding box from the AxisAlignedBoundingBox." }, "create_from_oriented_bounding_box": { "open3d.geometry.LineSet": "Factory function to create a LineSet from an OrientedBoundingBox." }, "create_from_point_cloud_correspondences": { "open3d.geometry.LineSet": "Factory function to create a LineSet from two pointclouds and a correspondence set." }, "create_from_tetra_mesh": { "open3d.geometry.LineSet": "Factory function to create a LineSet from edges of a tetra mesh." }, "get_line_coordinate": { "open3d.geometry.LineSet": "line_index (int) \u2013 Index of the line." }, "has_colors": { "open3d.geometry.LineSet": "Returns True if the object\u2019s lines contain colors.", "open3d.geometry.PointCloud": "Returns True if the point cloud contains point colors.", "open3d.geometry.VoxelGrid": "Returns True if the voxel grid contains voxel colors." }, "has_lines": { "open3d.geometry.LineSet": "Returns True if the object contains lines." }, "has_points": { "open3d.geometry.LineSet": "Returns True if the object contains points.", "open3d.geometry.PointCloud": "Returns True if the point cloud contains points." }, "colors": { "open3d.geometry.LineSet": "RGB colors of lines.", "open3d.geometry.PointCloud": "RGB colors of points." }, "lines": { "open3d.geometry.LineSet": "Lines denoted by the index of points forming the line." }, "points": { "open3d.geometry.LineSet": "Points coordinates.", "open3d.geometry.PointCloud": "Points coordinates." }, "convert_from_point_cloud": { "open3d.geometry.Octree": "Convert octree from point cloud." }, "create_from_voxel_grid": { "open3d.geometry.Octree": "None" }, "insert_point": { "open3d.geometry.Octree": "Insert a point to the octree." }, "is_point_in_bound": { "open3d.geometry.Octree": "Return true if point within bound, that is, origin<= point < origin + size" }, "locate_leaf_node": { "open3d.geometry.Octree": "Returns leaf OctreeNode and OctreeNodeInfo where the querypoint should reside." }, "to_voxel_grid": { "open3d.geometry.Octree": "Convert to VoxelGrid." }, "traverse": { "open3d.geometry.Octree": "DFS traversal of the octree from the root, with a callback function f being called for each node." }, "max_depth": { "open3d.geometry.Octree": "Maximum depth of the octree. The depth is defined as the distance from the deepest leaf node to root. A tree with only the root node has depth 0." }, "origin": { "open3d.geometry.Octree": "Global min bound (include). A point is within bound iff origin <= point < origin + size.", "open3d.geometry.OctreeNodeInfo": "Origin coordinate of the node.", "open3d.geometry.VoxelGrid": "Coorindate of the origin point." }, "root_node": { "open3d.geometry.Octree": "The root octree node." }, "get_init_function": { "open3d.geometry.OctreeColorLeafNode": "Get lambda function for initializing OctreeLeafNode. When the init function is called, an empty OctreeColorLeafNode is created.", "open3d.geometry.OctreeInternalNode": "Get lambda function for initializing OctreeInternalNode. When the init function is called, an empty OctreeInternalNode is created.", "open3d.geometry.OctreeInternalPointNode": "Get lambda function for initializing OctreeInternalPointNode. When the init function is called, an empty OctreeInternalPointNode is created.", "open3d.geometry.OctreePointColorLeafNode": "Get lambda function for initializing OctreeLeafNode. When the init function is called, an empty OctreePointColorLeafNode is created." }, "get_update_function": { "open3d.geometry.OctreeColorLeafNode": "Get lambda function for updating OctreeLeafNode. When called, the update function updates the corresponding node with the input color.", "open3d.geometry.OctreeInternalNode": "Get lambda function for updating OctreeInternalNode. This update function does nothing.", "open3d.geometry.OctreeInternalPointNode": "Get lambda function for updating OctreeInternalPointNode. When called, the update function adds the input point index to the corresponding node\u2019s list of indices of children points.", "open3d.geometry.OctreePointColorLeafNode": "Get lambda function for updating OctreeLeafNode. When called, the update function updates the corresponding node with the new point index and the input color." }, "children": { "open3d.geometry.OctreeInternalNode": "List of children Nodes.", "open3d.geometry.OctreeInternalPointNode": "List of children Nodes." }, "indices": { "open3d.geometry.OctreeInternalPointNode": "List of point cloud point indices contained in children nodes.", "open3d.geometry.OctreePointColorLeafNode": "List of point cloud point indices contained in this leaf node." }, "child_index": { "open3d.geometry.OctreeNodeInfo": "Node\u2019s child index of itself. For non-root nodes, child_index is 0~7; root node\u2019s child_index is -1." }, "depth": { "open3d.geometry.OctreeNodeInfo": "Depth of the node to the root. The root is of depth 0.", "open3d.geometry.RGBDImage": "The depth image.", "open3d.t.geometry.RGBDImage": "The depth image." }, "R": { "open3d.geometry.OrientedBoundingBox": "float64 array of shape (3,3 )" }, "center": { "open3d.geometry.OrientedBoundingBox": "float64 array of shape (3, )" }, "extent": { "open3d.geometry.OrientedBoundingBox": "float64 array of shape (3, )" }, "cluster_dbscan": { "open3d.geometry.PointCloud": "Cluster PointCloud using the DBSCAN algorithm Ester et al., \u2018A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise\u2019, 1996. Returns a list of point labels, -1 indicates noise according to the algorithm.", "open3d.t.geometry.PointCloud": "Cluster PointCloud using the DBSCAN algorithm Ester et al.,\u2019A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise\u2019, 1996. This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting labels will be made." }, "compute_mahalanobis_distance": { "open3d.geometry.PointCloud": "Function to compute the Mahalanobis distance for points in a point cloud. See: __URL__" }, "compute_mean_and_covariance": { "open3d.geometry.PointCloud": "Function to compute the mean and covariance matrix of a point cloud." }, "compute_nearest_neighbor_distance": { "open3d.geometry.PointCloud": "Function to compute the distance from a point to its nearest neighbor in the point cloud" }, "compute_point_cloud_distance": { "open3d.geometry.PointCloud": "For each point in the source point cloud, compute the distance to the target point cloud." }, "create_from_depth_image": { "open3d.geometry.PointCloud": "Factory function to create a pointcloud from a depth image and a camera. Given depth value d at (u, v) image coordinate, the corresponding 3d point is:", "open3d.t.geometry.PointCloud": "Factory function to create a pointcloud (with only \u2018points\u2019) from a depth image and a camera model." }, "create_from_rgbd_image": { "open3d.geometry.PointCloud": "Factory function to create a pointcloud from an RGB-D image and a camera. Given depth value d at (u, v) image coordinate, the corresponding 3d point is:", "open3d.t.geometry.PointCloud": "Factory function to create a pointcloud (with properties {\u2018points\u2019, \u2018colors\u2019}) from an RGBD image and a camera model." }, "crop": { "open3d.geometry.PointCloud": "Overloaded function.", "open3d.geometry.TriangleMesh": "Overloaded function.", "open3d.t.geometry.PointCloud": "Function to crop pointcloud into output pointcloud." }, "estimate_covariances": { "open3d.geometry.PointCloud": "Function to compute the covariance matrix for each point in the point cloud" }, "estimate_normals": { "open3d.geometry.PointCloud": "Function to compute the normals of a point cloud. Normals are oriented with respect to the input point cloud if normals exist", "open3d.t.geometry.PointCloud": "Function to estimate point normals. If the point cloud normals exist, the estimated normals are oriented with respect to the same. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided." }, "estimate_point_covariances": { "open3d.geometry.PointCloud": "Static function to compute the covariance matrix for each point in the given point cloud, doesn\u2019t change the input" }, "farthest_point_down_sample": { "open3d.geometry.PointCloud": "Downsamples input pointcloud into output pointcloud with a set of points has farthest distance. The sample is performed by selecting the farthest point from previous selected points iteratively.", "open3d.t.geometry.PointCloud": "Downsample a pointcloud into output pointcloud with a set of points has farthest distance.The sampling is performed by selecting the farthest point from previous selected points iteratively" }, "has_covariances": { "open3d.geometry.PointCloud": "Returns True if the point cloud contains covariances." }, "has_normals": { "open3d.geometry.PointCloud": "Returns True if the point cloud contains point normals." }, "hidden_point_removal": { "open3d.geometry.PointCloud": "Removes hidden points from a point cloud and returns a mesh of the remaining points. Based on Katz et al. \u2018Direct Visibility of Point Sets\u2019, 2007. Additional information about the choice of radius for noisy point clouds can be found in Mehra et. al. \u2018Visibility of Noisy Point Cloud Data\u2019, 2010.", "open3d.t.geometry.PointCloud": "Removes hidden points from a point cloud and returns a mesh of the remaining points. Based on Katz et al. \u2018Direct Visibility of Point Sets\u2019, 2007. Additional information about the choice of radius for noisy point clouds can be found in Mehra et. al. \u2018Visibility of Noisy Point Cloud Data\u2019, 2010. This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting visible triangle mesh and indiecs will be made." }, "orient_normals_consistent_tangent_plane": { "open3d.geometry.PointCloud": "Function to orient the normals with respect to consistent tangent planes" }, "orient_normals_to_align_with_direction": { "open3d.geometry.PointCloud": "Function to orient the normals of a point cloud" }, "orient_normals_towards_camera_location": { "open3d.geometry.PointCloud": "Function to orient the normals of a point cloud" }, "random_down_sample": { "open3d.geometry.PointCloud": "Function to downsample input pointcloud into output pointcloud randomly. The sample is generated by randomly sampling the indexes from the point cloud.", "open3d.t.geometry.PointCloud": "Downsample a pointcloud by selecting random index point and its attributes." }, "remove_duplicated_points": { "open3d.geometry.PointCloud": "Removes duplicated points, i.e., points that have identical coordinates. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn\u2019t re-computes these attributes after removing duplicated points.", "open3d.t.geometry.PointCloud": "Remove duplicated points and there associated attributes." }, "remove_non_finite_points": { "open3d.geometry.PointCloud": "Removes all points from the point cloud that have a nan entry, or infinite entries. It also removes the corresponding attributes associated with the non-finite point such as normals, covariances and color entries. It doesn\u2019t re-computes these attributes after removing non-finite points.", "open3d.t.geometry.PointCloud": "Remove all points from the point cloud that have a nan entry, or infinite value. It also removes the corresponding attributes." }, "remove_radius_outlier": { "open3d.geometry.PointCloud": "Removes points that have neighbors less than nb_points in a sphere of a given radius" }, "remove_statistical_outlier": { "open3d.geometry.PointCloud": "Removes points that are further away from their neighbors in average." }, "segment_plane": { "open3d.geometry.PointCloud": "Segments a plane in the point cloud using the RANSAC algorithm.", "open3d.t.geometry.PointCloud": "Segments a plane in the point cloud using the RANSAC algorithm. This is a wrapper for a CPU implementation and a copy of the point cloud data and resulting plane model and inlier indiecs will be made." }, "select_by_index": { "open3d.geometry.PointCloud": "Function to select points from input pointcloud into output pointcloud.", "open3d.geometry.TriangleMesh": "Function to select mesh from input triangle mesh into output triangle mesh. input: The input triangle mesh. indices: Indices of vertices to be selected.", "open3d.t.geometry.PointCloud": "Select points from input pointcloud, based on indices into output point cloud." }, "uniform_down_sample": { "open3d.geometry.PointCloud": "Function to downsample input pointcloud into output pointcloud uniformly. The sample is performed in the order of the points with the 0-th point always chosen, not at random.", "open3d.t.geometry.PointCloud": "Downsamples a point cloud by selecting every kth index point and its attributes." }, "voxel_down_sample": { "open3d.geometry.PointCloud": "Function to downsample input pointcloud into output pointcloud with a voxel. Normals and colors are averaged if they exist.", "open3d.t.geometry.PointCloud": "Downsamples a point cloud with a specified voxel size." }, "voxel_down_sample_and_trace": { "open3d.geometry.PointCloud": "Function to downsample using PointCloud.VoxelDownSample. Also records point cloud index before downsampling" }, "covariances": { "open3d.geometry.PointCloud": "Points covariances." }, "normals": { "open3d.geometry.PointCloud": "Points normals." }, "create_from_color_and_depth": { "open3d.geometry.RGBDImage": "Function to make RGBDImage from color and depth image" }, "create_from_nyu_format": { "open3d.geometry.RGBDImage": "Function to make RGBDImage (for NYU format)" }, "create_from_redwood_format": { "open3d.geometry.RGBDImage": "Function to make RGBDImage (for Redwood format)" }, "create_from_sun_format": { "open3d.geometry.RGBDImage": "Function to make RGBDImage (for SUN format)" }, "create_from_tum_format": { "open3d.geometry.RGBDImage": "Function to make RGBDImage (for TUM format)" }, "create_from_point_cloud": { "open3d.geometry.TetraMesh": "Function to create a tetrahedral mesh from a point cloud.", "open3d.geometry.VoxelGrid": "Creates a VoxelGrid from a given PointCloud. The color value of a given voxel is the average color value of the points that fall into it (if the PointCloud has colors). The bounds of the created VoxelGrid are computed from the PointCloud." }, "extract_triangle_mesh": { "open3d.geometry.TetraMesh": "Function that generates a triangle mesh of the specified iso-surface.", "open3d.pipelines.integration.ScalableTSDFVolume": "Function to extract a triangle mesh", "open3d.pipelines.integration.TSDFVolume": "Function to extract a triangle mesh", "open3d.pipelines.integration.UniformTSDFVolume": "Function to extract a triangle mesh", "open3d.t.geometry.VoxelBlockGrid": "Specific operation for TSDF volumes.Extract triangle mesh at isosurface points." }, "has_tetras": { "open3d.geometry.TetraMesh": "Returns True if the mesh contains tetras." }, "remove_degenerate_tetras": { "open3d.geometry.TetraMesh": "Function that removes degenerate tetras, i.e., tetras that references a single vertex multiple times in a single tetra. They are usually the product of removing duplicated vertices." }, "remove_duplicated_tetras": { "open3d.geometry.TetraMesh": "Function that removes duplicated tetras, i.e., removes tetras that reference the same four vertices, independent of their order." }, "remove_duplicated_vertices": { "open3d.geometry.TetraMesh": "Function that removes duplicated vertices, i.e., vertices that have identical coordinates.", "open3d.geometry.TriangleMesh": "Function that removes duplicated vertices, i.e., vertices that have identical coordinates." }, "remove_unreferenced_vertices": { "open3d.geometry.TetraMesh": "This function removes vertices from the tetra mesh that are not referenced in any tetra of the mesh.", "open3d.geometry.TriangleMesh": "This function removes vertices from the triangle mesh that are not referenced in any triangle of the mesh." }, "tetras": { "open3d.geometry.TetraMesh": "List of tetras denoted by the index of points forming the tetra." }, "cluster_connected_triangles": { "open3d.geometry.TriangleMesh": "Function that clusters connected triangles, i.e., triangles that are connected via edges are assigned the same cluster index. This function returns an array that contains the cluster index per triangle, a second array contains the number of triangles per cluster, and a third vector contains the surface area per cluster." }, "compute_adjacency_list": { "open3d.geometry.TriangleMesh": "Function to compute adjacency list, call before adjacency list is needed" }, "compute_triangle_normals": { "open3d.geometry.TriangleMesh": "Function to compute triangle normals, usually called before rendering" }, "compute_vertex_normals": { "open3d.geometry.TriangleMesh": "Function to compute vertex normals, usually called before rendering" }, "create_arrow": { "open3d.geometry.TriangleMesh": "Factory function to create an arrow mesh", "open3d.t.geometry.TriangleMesh": "Create a arrow mesh." }, "create_box": { "open3d.geometry.TriangleMesh": "Factory function to create a box. The left bottom corner on the front will be placed at (0, 0, 0), and default UV map, maps the entire texture to each face.", "open3d.t.geometry.TriangleMesh": "height (float, optional, default=1.0) \u2013 y-directional length." }, "create_cone": { "open3d.geometry.TriangleMesh": "Factory function to create a cone mesh.", "open3d.t.geometry.TriangleMesh": "Create a cone mesh." }, "create_coordinate_frame": { "open3d.geometry.TriangleMesh": "Factory function to create a coordinate frame mesh. The coordinate frame will be centered at origin. The x, y, z axis will be rendered as red, green, and blue arrows respectively.", "open3d.t.geometry.TriangleMesh": "Create a coordinate frame mesh." }, "create_cylinder": { "open3d.geometry.TriangleMesh": "Factory function to create a cylinder mesh.", "open3d.t.geometry.TriangleMesh": "Create a cylinder mesh." }, "create_from_point_cloud_alpha_shape": { "open3d.geometry.TriangleMesh": "Overloaded function." }, "create_from_point_cloud_ball_pivoting": { "open3d.geometry.TriangleMesh": "Function that computes a triangle mesh from a oriented PointCloud. This implements the Ball Pivoting algorithm proposed in F. Bernardini et al., \u201cThe ball-pivoting algorithm for surface reconstruction\u201d, 1999. The implementation is also based on the algorithms outlined in Digne, \u201cAn Analysis and Implementation of a Parallel Ball Pivoting Algorithm\u201d, 2014. The surface reconstruction is done by rolling a ball with a given radius over the point cloud, whenever the ball touches three points a triangle is created." }, "create_from_point_cloud_poisson": { "open3d.geometry.TriangleMesh": "Function that computes a triangle mesh from a oriented PointCloud pcd. This implements the Screened Poisson Reconstruction proposed in Kazhdan and Hoppe, \u201cScreened Poisson Surface Reconstruction\u201d, 2013. This function uses the original implementation by Kazhdan. See __URL__" }, "create_icosahedron": { "open3d.geometry.TriangleMesh": "Factory function to create a icosahedron. The centroid of the mesh will be placed at (0, 0, 0) and the vertices have a distance of radius to the center.", "open3d.t.geometry.TriangleMesh": "Create a icosahedron mesh centered at (0, 0, 0)." }, "create_mobius": { "open3d.geometry.TriangleMesh": "Factory function to create a Mobius strip.", "open3d.t.geometry.TriangleMesh": "Create a Mobius strip." }, "create_octahedron": { "open3d.geometry.TriangleMesh": "Factory function to create a octahedron. The centroid of the mesh will be placed at (0, 0, 0) and the vertices have a distance of radius to the center.", "open3d.t.geometry.TriangleMesh": "Create a octahedron mesh centered at (0, 0, 0)." }, "create_sphere": { "open3d.geometry.TriangleMesh": "Factory function to create a sphere mesh centered at (0, 0, 0).", "open3d.t.geometry.TriangleMesh": "Create a sphere mesh centered at (0, 0, 0)." }, "create_tetrahedron": { "open3d.geometry.TriangleMesh": "Factory function to create a tetrahedron. The centroid of the mesh will be placed at (0, 0, 0) and the vertices have a distance of radius to the center.", "open3d.t.geometry.TriangleMesh": "Create a tetrahedron mesh centered at (0, 0, 0)." }, "create_torus": { "open3d.geometry.TriangleMesh": "Factory function to create a torus mesh.", "open3d.t.geometry.TriangleMesh": "Create a torus mesh." }, "deform_as_rigid_as_possible": { "open3d.geometry.TriangleMesh": "This function deforms the mesh using the method by Sorkine and Alexa, \u2018As-Rigid-As-Possible Surface Modeling\u2019, 2007" }, "euler_poincare_characteristic": { "open3d.geometry.TriangleMesh": "Function that computes the Euler-Poincar\u00e9 characteristic, i.e., V + F - E, where V is the number of vertices, F is the number of triangles, and E is the number of edges." }, "filter_sharpen": { "open3d.geometry.TriangleMesh": "Function to sharpen triangle mesh. The output value (\\ (v_o\\)) is the input value (\\ (v_i\\)) plus strength times the input value minus he sum of he adjacent values. \\ (v_o = v_i x strength (v_i * |N| - \\sum_{n \\in N} v_n)\\)" }, "filter_smooth_laplacian": { "open3d.geometry.TriangleMesh": "Function to smooth triangle mesh using Laplacian. \\ (v_o = v_i \\cdot \\lambda (sum_{n \\in N} w_n v_n - v_i)\\), with \\ (v_i\\) being the input value, \\ (v_o\\) the output value, \\ (N\\) is the set of adjacent neighbours, \\ (w_n\\) is the weighting of the neighbour based on the inverse distance (closer neighbours have higher weight), and lambda_filter is the smoothing parameter." }, "filter_smooth_simple": { "open3d.geometry.TriangleMesh": "Function to smooth triangle mesh with simple neighbour average. \\ (v_o = \\frac{v_i + \\sum_{n \\in N} v_n)}{|N| + 1}\\), with \\ (v_i\\) being the input value, \\ (v_o\\) the output value, and \\ (N\\) is the set of adjacent neighbours." }, "filter_smooth_taubin": { "open3d.geometry.TriangleMesh": "Function to smooth triangle mesh using method of Taubin, \u201cCurve and Surface Smoothing Without Shrinkage\u201d, 1995. Applies in each iteration two times filter_smooth_laplacian, first with filter parameter lambda_filter and second with filter parameter mu as smoothing parameter. This method avoids shrinkage of the triangle mesh." }, "get_non_manifold_edges": { "open3d.geometry.TriangleMesh": "Get list of non-manifold edges." }, "get_non_manifold_vertices": { "open3d.geometry.TriangleMesh": "Returns a list of indices to non-manifold vertices." }, "get_self_intersecting_triangles": { "open3d.geometry.TriangleMesh": "Returns a list of indices to triangles that intersect the mesh." }, "get_surface_area": { "open3d.geometry.TriangleMesh": "Function that computes the surface area of the mesh, i.e. the sum of the individual triangle surfaces." }, "get_volume": { "open3d.geometry.TriangleMesh": "Function that computes the volume of the mesh, under the condition that it is watertight and orientable." }, "has_adjacency_list": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains adjacency normals." }, "has_textures": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains a texture image." }, "has_triangle_material_ids": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains material ids." }, "has_triangle_normals": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains triangle normals." }, "has_triangle_uvs": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains uv coordinates." }, "has_triangles": { "open3d.geometry.TriangleMesh": "Returns True if the mesh contains triangles." }, "is_edge_manifold": { "open3d.geometry.TriangleMesh": "Tests if the triangle mesh is edge manifold." }, "is_intersecting": { "open3d.geometry.TriangleMesh": "Tests if the triangle mesh is intersecting the other triangle mesh." }, "is_orientable": { "open3d.geometry.TriangleMesh": "Tests if the triangle mesh is orientable." }, "is_self_intersecting": { "open3d.geometry.TriangleMesh": "Tests if the triangle mesh is self-intersecting." }, "is_vertex_manifold": { "open3d.geometry.TriangleMesh": "Tests if all vertices of the triangle mesh are manifold." }, "is_watertight": { "open3d.geometry.TriangleMesh": "Tests if the triangle mesh is watertight." }, "merge_close_vertices": { "open3d.geometry.TriangleMesh": "Function that will merge close by vertices to a single one. The vertex position, normal and color will be the average of the vertices. The parameter eps defines the maximum distance of close by vertices. This function might help to close triangle soups." }, "orient_triangles": { "open3d.geometry.TriangleMesh": "If the mesh is orientable this function orients all triangles such that all normals point towards the same direction." }, "remove_degenerate_triangles": { "open3d.geometry.TriangleMesh": "Function that removes degenerate triangles, i.e., triangles that references a single vertex multiple times in a single triangle. They are usually the product of removing duplicated vertices." }, "remove_duplicated_triangles": { "open3d.geometry.TriangleMesh": "Function that removes duplicated triangles, i.e., removes triangles that reference the same three vertices and have the same orientation." }, "remove_non_manifold_edges": { "open3d.geometry.TriangleMesh": "Function that removes all non-manifold edges, by successively deleting triangles with the smallest surface area adjacent to the non-manifold edge until the number of adjacent triangles to the edge is <= 2." }, "remove_triangles_by_index": { "open3d.geometry.TriangleMesh": "This function removes the triangles with index in triangle_indices. Call remove_unreferenced_vertices to clean up vertices afterwards." }, "remove_triangles_by_mask": { "open3d.geometry.TriangleMesh": "This function removes the triangles where triangle_mask is set to true. Call remove_unreferenced_vertices to clean up vertices afterwards." }, "remove_vertices_by_index": { "open3d.geometry.TriangleMesh": "This function removes the vertices with index in vertex_indices. Note that also all triangles associated with the vertices are removed." }, "remove_vertices_by_mask": { "open3d.geometry.TriangleMesh": "This function removes the vertices that are masked in vertex_mask. Note that also all triangles associated with the vertices are removed." }, "sample_points_poisson_disk": { "open3d.geometry.TriangleMesh": "Function to sample points from the mesh, where each point has approximately the same distance to the neighbouring points (blue noise). Method is based on Yuksel, \u201cSample Elimination for Generating Poisson Disk Sample Sets\u201d, EUROGRAPHICS, 2015." }, "sample_points_uniformly": { "open3d.geometry.TriangleMesh": "Function to uniformly sample points from the mesh." }, "simplify_quadric_decimation": { "open3d.geometry.TriangleMesh": "Function to simplify mesh using Quadric Error Metric Decimation by Garland and Heckbert", "open3d.t.geometry.TriangleMesh": "Function to simplify mesh using Quadric Error Metric Decimation by Garland and Heckbert." }, "simplify_vertex_clustering": { "open3d.geometry.TriangleMesh": "Function to simplify mesh using vertex clustering." }, "subdivide_loop": { "open3d.geometry.TriangleMesh": "Function subdivide mesh using Loop\u2019s algorithm. Loop, \u201cSmooth subdivision surfaces based on triangles\u201d, 1987." }, "subdivide_midpoint": { "open3d.geometry.TriangleMesh": "Function subdivide mesh using midpoint algorithm." }, "adjacency_list": { "open3d.geometry.TriangleMesh": "The set adjacency_list[i] contains the indices of adjacent vertices of vertex i." }, "textures": { "open3d.geometry.TriangleMesh": "The texture images." }, "triangle_material_ids": { "open3d.geometry.TriangleMesh": "material index associated with each triangle" }, "triangle_uvs": { "open3d.geometry.TriangleMesh": "List of uvs denoted by the index of points forming the triangle." }, "grid_index": { "open3d.geometry.Voxel": "Grid coordinate index of the voxel." }, "carve_depth_map": { "open3d.geometry.VoxelGrid": "Remove all voxels from the VoxelGrid where none of the boundary points of the voxel projects to depth value that is smaller, or equal than the projected depth of the boundary point. If keep_voxels_outside_image is true then voxels are only carved if all boundary points project to a valid image location." }, "carve_silhouette": { "open3d.geometry.VoxelGrid": "Remove all voxels from the VoxelGrid where none of the boundary points of the voxel projects to a valid mask pixel (pixel value > 0). If keep_voxels_outside_image is true then voxels are only carved if all boundary points project to a valid image location." }, "check_if_included": { "open3d.geometry.VoxelGrid": "Element-wise check if a query in the list is included in the VoxelGrid. Queries are double precision and are mapped to the closest voxel." }, "create_dense": { "open3d.geometry.VoxelGrid": "Creates a voxel grid where every voxel is set (hence dense). This is a useful starting point for voxel carving" }, "create_from_octree": { "open3d.geometry.VoxelGrid": "Convert from Octree." }, "create_from_point_cloud_within_bounds": { "open3d.geometry.VoxelGrid": "Creates a VoxelGrid from a given PointCloud. The color value of a given voxel is the average color value of the points that fall into it (if the PointCloud has colors). The bounds of the created VoxelGrid are defined by the given parameters." }, "create_from_triangle_mesh_within_bounds": { "open3d.geometry.VoxelGrid": "Creates a VoxelGrid from a given TriangleMesh. No color information is converted. The bounds of the created VoxelGrid are defined by the given parameters" }, "get_voxel": { "open3d.geometry.VoxelGrid": "Returns voxel index given query point." }, "get_voxel_bounding_points": { "open3d.geometry.VoxelGrid": "Returns the 8 bounding points of a voxel given its grid index." }, "get_voxel_center_coordinate": { "open3d.geometry.VoxelGrid": "Returns the center coordinate of a voxel given its grid index." }, "get_voxels": { "open3d.geometry.VoxelGrid": "Returns List of Voxel: Voxels contained in voxel grid. Changes to the voxels returned from this methodare not reflected in the voxel grid." }, "has_voxels": { "open3d.geometry.VoxelGrid": "Returns True if the voxel grid contains voxels." }, "to_octree": { "open3d.geometry.VoxelGrid": "Convert to Octree." }, "voxel_size": { "open3d.geometry.VoxelGrid": "float64 Size of the voxel.", "open3d.t.pipelines.slac.slac_optimizer_params": "Voxel size to downsample input point cloud." }, "stream_length_usec": { "open3d.io.AzureKinectMKVMetadata": "Length of the video (usec)", "open3d.t.io.RGBDVideoMetadata": "Length of the video (usec). 0 for live capture." }, "close": { "open3d.io.AzureKinectMKVReader": "Close the opened mkv playback.", "open3d.t.io.RSBagReader": "Close the opened RS bag playback.", "open3d.visualization.O3DVisualizer": "Closes the window and destroys it, unless an on_close callback cancels the close.", "open3d.visualization.Visualizer": "Function to notify the window to be closed", "open3d.visualization.VisualizerWithEditing": "Function to notify the window to be closed", "open3d.visualization.VisualizerWithKeyCallback": "Function to notify the window to be closed", "open3d.visualization.VisualizerWithVertexSelection": "Function to notify the window to be closed", "open3d.visualization.gui.Window": "Closes the window and destroys it, unless an on_close callback cancels the close." }, "get_metadata": { "open3d.io.AzureKinectMKVReader": "Get metadata of the mkv playback.", "open3d.t.io.RealSenseSensor": "Get metadata of the RealSense video capture." }, "is_eof": { "open3d.io.AzureKinectMKVReader": "Check if the mkv file is all read.", "open3d.t.io.RSBagReader": "Check if the RS bag file is all read." }, "is_opened": { "open3d.io.AzureKinectMKVReader": "Check if the mkv file is opened.", "open3d.t.io.RSBagReader": "Check if the RS bag file is opened." }, "next_frame": { "open3d.io.AzureKinectMKVReader": "Get next frame from the mkv playback and returns the RGBD object.", "open3d.t.io.RSBagReader": "Get next frame from the RS bag playback and returns the RGBD object." }, "open": { "open3d.io.AzureKinectMKVReader": "Open an mkv playback.", "open3d.t.io.RSBagReader": "Open an RS bag playback." }, "seek_timestamp": { "open3d.io.AzureKinectMKVReader": "Seek to the timestamp (in us).", "open3d.t.io.RSBagReader": "Seek to the timestamp (in us)." }, "close_record": { "open3d.io.AzureKinectRecorder": "Close the recorded mkv file." }, "init_sensor": { "open3d.io.AzureKinectRecorder": "Initialize sensor.", "open3d.t.io.RealSenseSensor": "Overloaded function." }, "is_record_created": { "open3d.io.AzureKinectRecorder": "Check if the mkv file is created." }, "open_record": { "open3d.io.AzureKinectRecorder": "Attempt to create and open an mkv file." }, "record_frame": { "open3d.io.AzureKinectRecorder": "Record a frame to mkv if flag is on and return an RGBD object." }, "capture_frame": { "open3d.io.AzureKinectSensor": "Capture an RGBD frame.", "open3d.t.io.RealSenseSensor": "Acquire the next synchronized RGBD frameset from the camera." }, "connect": { "open3d.io.AzureKinectSensor": "Connect to specified device." }, "disconnect": { "open3d.io.AzureKinectSensor": "Disconnect from the connected device." }, "list_devices": { "open3d.io.AzureKinectSensor": "List available Azure Kinect devices", "open3d.t.io.RealSenseSensor": "List all RealSense cameras connected to the system along with their capabilities. Use this listing to select an appropriate configuration for a camera" }, "get_buffer": { "open3d.io.rpc.BufferConnection": "Returns a copy of the buffer." }, "get_loader": { "open3d.ml.tf.dataloaders.TFDataloader": "This constructs the tensorflow dataloader." }, "read_data": { "open3d.ml.tf.dataloaders.TFDataloader": "Returns the data at the index." }, "get_label_to_names": { "open3d.ml.tf.datasets.Argoverse": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Custom3D": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.KITTI": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Lyft": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.MatterportObjects": "Returns a label to names dictonary object.", "open3d.ml.tf.datasets.NuScenes": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.ParisLille3D": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.S3DIS": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Scannet": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Semantic3D": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.SemanticKITTI": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.ShapeNet": "Returns a label to names dictionary object depending on the task. The valid values for task for classification and segmentation.", "open3d.ml.tf.datasets.SunRGBD": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Toronto3D": "Returns a label to names dictionary object.", "open3d.ml.tf.datasets.Waymo": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Argoverse": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Custom3D": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.KITTI": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Lyft": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.MatterportObjects": "Returns a label to names dictonary object.", "open3d.ml.torch.datasets.NuScenes": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.ParisLille3D": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.S3DIS": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Scannet": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Semantic3D": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.SemanticKITTI": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.ShapeNet": "Returns a label to names dictionary object depending on the task. The valid values for task for classification and segmentation.", "open3d.ml.torch.datasets.SunRGBD": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Toronto3D": "Returns a label to names dictionary object.", "open3d.ml.torch.datasets.Waymo": "Returns a label to names dictionary object." }, "get_split": { "open3d.ml.tf.datasets.Argoverse": "Returns a dataset split.", "open3d.ml.tf.datasets.Custom3D": "Returns a dataset split.", "open3d.ml.tf.datasets.KITTI": "Returns a dataset split.", "open3d.ml.tf.datasets.Lyft": "Returns a dataset split.", "open3d.ml.tf.datasets.MatterportObjects": "Returns a dataset split.", "open3d.ml.tf.datasets.NuScenes": "Returns a dataset split.", "open3d.ml.tf.datasets.ParisLille3D": "Returns a dataset split.", "open3d.ml.tf.datasets.S3DIS": "Returns a dataset split.", "open3d.ml.tf.datasets.Scannet": "Returns a dataset split.", "open3d.ml.tf.datasets.Semantic3D": "Returns a dataset split.", "open3d.ml.tf.datasets.SemanticKITTI": "Returns a dataset split.", "open3d.ml.tf.datasets.ShapeNet": "Returns a dataset split.", "open3d.ml.tf.datasets.SunRGBD": "Returns a dataset split.", "open3d.ml.tf.datasets.Toronto3D": "Returns a dataset split.", "open3d.ml.tf.datasets.Waymo": "Returns a dataset split.", "open3d.ml.torch.datasets.Argoverse": "Returns a dataset split.", "open3d.ml.torch.datasets.Custom3D": "Returns a dataset split.", "open3d.ml.torch.datasets.KITTI": "Returns a dataset split.", "open3d.ml.torch.datasets.Lyft": "Returns a dataset split.", "open3d.ml.torch.datasets.MatterportObjects": "Returns a dataset split.", "open3d.ml.torch.datasets.NuScenes": "Returns a dataset split.", "open3d.ml.torch.datasets.ParisLille3D": "Returns a dataset split.", "open3d.ml.torch.datasets.S3DIS": "Returns a dataset split.", "open3d.ml.torch.datasets.Scannet": "Returns a dataset split.", "open3d.ml.torch.datasets.Semantic3D": "Returns a dataset split.", "open3d.ml.torch.datasets.SemanticKITTI": "Returns a dataset split.", "open3d.ml.torch.datasets.ShapeNet": "Returns a dataset split.", "open3d.ml.torch.datasets.SunRGBD": "Returns a dataset split.", "open3d.ml.torch.datasets.Toronto3D": "Returns a dataset split.", "open3d.ml.torch.datasets.Waymo": "Returns a dataset split." }, "get_split_list": { "open3d.ml.tf.datasets.Argoverse": "Returns a dataset split.", "open3d.ml.tf.datasets.Custom3D": "Returns a dataset split.", "open3d.ml.tf.datasets.KITTI": "Returns the list of data splits available.", "open3d.ml.tf.datasets.Lyft": "Returns the list of data splits available.", "open3d.ml.tf.datasets.MatterportObjects": "Returns the list of data splits available.", "open3d.ml.tf.datasets.NuScenes": "Returns the list of data splits available.", "open3d.ml.tf.datasets.ParisLille3D": "Returns a dataset split.", "open3d.ml.tf.datasets.Semantic3D": "Returns the list of data splits available.", "open3d.ml.tf.datasets.SemanticKITTI": "Returns a dataset split.", "open3d.ml.tf.datasets.ShapeNet": "Returns the list of data splits available.", "open3d.ml.tf.datasets.Toronto3D": "Returns the list of data splits available.", "open3d.ml.tf.datasets.Waymo": "Returns the list of data splits available.", "open3d.ml.torch.datasets.Argoverse": "Returns a dataset split.", "open3d.ml.torch.datasets.Custom3D": "Returns a dataset split.", "open3d.ml.torch.datasets.KITTI": "Returns the list of data splits available.", "open3d.ml.torch.datasets.Lyft": "Returns the list of data splits available.", "open3d.ml.torch.datasets.MatterportObjects": "Returns the list of data splits available.", "open3d.ml.torch.datasets.NuScenes": "Returns the list of data splits available.", "open3d.ml.torch.datasets.ParisLille3D": "Returns a dataset split.", "open3d.ml.torch.datasets.Semantic3D": "Returns the list of data splits available.", "open3d.ml.torch.datasets.SemanticKITTI": "Returns a dataset split.", "open3d.ml.torch.datasets.ShapeNet": "Returns the list of data splits available.", "open3d.ml.torch.datasets.Toronto3D": "Returns the list of data splits available.", "open3d.ml.torch.datasets.Waymo": "Returns the list of data splits available." }, "is_tested": { "open3d.ml.tf.datasets.Argoverse": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.Custom3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.KITTI": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.Lyft": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.MatterportObjects": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.NuScenes": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.ParisLille3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.S3DIS": "Checks whether a datum has been tested.", "open3d.ml.tf.datasets.Scannet": "Checks whether a datum has been tested.", "open3d.ml.tf.datasets.Semantic3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.SemanticKITTI": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.ShapeNet": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.SunRGBD": "Checks whether a datum has been tested.", "open3d.ml.tf.datasets.Toronto3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.tf.datasets.Waymo": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.Argoverse": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.Custom3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.KITTI": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.Lyft": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.MatterportObjects": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.NuScenes": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.ParisLille3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.S3DIS": "Checks whether a datum has been tested.", "open3d.ml.torch.datasets.Scannet": "Checks whether a datum has been tested.", "open3d.ml.torch.datasets.Semantic3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.SemanticKITTI": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.ShapeNet": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.SunRGBD": "Checks whether a datum has been tested.", "open3d.ml.torch.datasets.Toronto3D": "Checks if a datum in the dataset has been tested.", "open3d.ml.torch.datasets.Waymo": "Checks if a datum in the dataset has been tested." }, "read_label": { "open3d.ml.tf.datasets.Argoverse": "Reads labels of bound boxes.", "open3d.ml.tf.datasets.KITTI": "Reads labels of bound boxes.", "open3d.ml.tf.datasets.Lyft": "Reads labels of bound boxes.", "open3d.ml.tf.datasets.MatterportObjects": "Reads labels of bound boxes.", "open3d.ml.tf.datasets.NuScenes": "Reads labels of bound boxes.", "open3d.ml.tf.datasets.Waymo": "Reads labels of bounding boxes.", "open3d.ml.torch.datasets.Argoverse": "Reads labels of bound boxes.", "open3d.ml.torch.datasets.KITTI": "Reads labels of bound boxes.", "open3d.ml.torch.datasets.Lyft": "Reads labels of bound boxes.", "open3d.ml.torch.datasets.MatterportObjects": "Reads labels of bound boxes.", "open3d.ml.torch.datasets.NuScenes": "Reads labels of bound boxes.", "open3d.ml.torch.datasets.Waymo": "Reads labels of bounding boxes." }, "read_lidar": { "open3d.ml.tf.datasets.Argoverse": "Reads lidar data from the path provided.", "open3d.ml.tf.datasets.KITTI": "Reads lidar data from the path provided.", "open3d.ml.tf.datasets.Lyft": "Reads lidar data from the path provided.", "open3d.ml.tf.datasets.MatterportObjects": "Reads lidar data from the path provided.", "open3d.ml.tf.datasets.NuScenes": "Reads lidar data from the path provided.", "open3d.ml.tf.datasets.Waymo": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.Argoverse": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.KITTI": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.Lyft": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.MatterportObjects": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.NuScenes": "Reads lidar data from the path provided.", "open3d.ml.torch.datasets.Waymo": "Reads lidar data from the path provided." }, "save_test_result": { "open3d.ml.tf.datasets.Argoverse": "Saves the output of a model.", "open3d.ml.tf.datasets.Custom3D": "Saves the output of a model.", "open3d.ml.tf.datasets.KITTI": "Saves the output of a model.", "open3d.ml.tf.datasets.Lyft": "Saves the output of a model.", "open3d.ml.tf.datasets.MatterportObjects": "Saves the output of a model.", "open3d.ml.tf.datasets.NuScenes": "Saves the output of a model.", "open3d.ml.tf.datasets.ParisLille3D": "Saves the output of a model.", "open3d.ml.tf.datasets.S3DIS": "Saves the output of a model.", "open3d.ml.tf.datasets.Scannet": "Saves the output of a model.", "open3d.ml.tf.datasets.Semantic3D": "Saves the output of a model.", "open3d.ml.tf.datasets.SemanticKITTI": "Saves the output of a model.", "open3d.ml.tf.datasets.ShapeNet": "Saves the output of a model.", "open3d.ml.tf.datasets.SunRGBD": "Saves the output of a model.", "open3d.ml.tf.datasets.Toronto3D": "Saves the output of a model.", "open3d.ml.tf.datasets.Waymo": "Saves the output of a model.", "open3d.ml.torch.datasets.Argoverse": "Saves the output of a model.", "open3d.ml.torch.datasets.Custom3D": "Saves the output of a model.", "open3d.ml.torch.datasets.KITTI": "Saves the output of a model.", "open3d.ml.torch.datasets.Lyft": "Saves the output of a model.", "open3d.ml.torch.datasets.MatterportObjects": "Saves the output of a model.", "open3d.ml.torch.datasets.NuScenes": "Saves the output of a model.", "open3d.ml.torch.datasets.ParisLille3D": "Saves the output of a model.", "open3d.ml.torch.datasets.S3DIS": "Saves the output of a model.", "open3d.ml.torch.datasets.Scannet": "Saves the output of a model.", "open3d.ml.torch.datasets.Semantic3D": "Saves the output of a model.", "open3d.ml.torch.datasets.SemanticKITTI": "Saves the output of a model.", "open3d.ml.torch.datasets.ShapeNet": "Saves the output of a model.", "open3d.ml.torch.datasets.SunRGBD": "Saves the output of a model.", "open3d.ml.torch.datasets.Toronto3D": "Saves the output of a model.", "open3d.ml.torch.datasets.Waymo": "Saves the output of a model." }, "get_attr": { "open3d.ml.tf.datasets.InferenceDummySplit": "Returns the attributes for the given index.", "open3d.ml.tf.vis.Model": "Get an attribute from data based on the name passed.", "open3d.ml.torch.datasets.InferenceDummySplit": "Returns the attributes for the given index.", "open3d.ml.torch.vis.Model": "Get an attribute from data based on the name passed." }, "get_data": { "open3d.ml.tf.datasets.InferenceDummySplit": "Returns the data for the given index.", "open3d.ml.torch.datasets.InferenceDummySplit": "Returns the data for the given index.", "open3d.t.pipelines.slam.Frame": "Get a 2D tensor from a image from the given key in the map." }, "read_calib": { "open3d.ml.tf.datasets.KITTI": "Reads calibiration for the dataset. You can use them to compare modeled results to observed results.", "open3d.ml.tf.datasets.Waymo": "Reads calibiration for the dataset. You can use them to compare modeled results to observed results.", "open3d.ml.torch.datasets.KITTI": "Reads calibiration for the dataset. You can use them to compare modeled results to observed results.", "open3d.ml.torch.datasets.Waymo": "Reads calibiration for the dataset. You can use them to compare modeled results to observed results." }, "read_cams": { "open3d.ml.tf.datasets.NuScenes": "Reads image data from the cam dict provided.", "open3d.ml.torch.datasets.NuScenes": "Reads image data from the cam dict provided." }, "ObjectRangeFilter": { "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Filter Objects in the given range.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Filter Objects in the given range." }, "ObjectSample": { "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Increase frequency of objects in a pointcloud.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Increase frequency of objects in a pointcloud." }, "PointShuffle": { "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Shuffle Pointcloud.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Shuffle Pointcloud." }, "augment": { "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Augment object detection data.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Augment object detection data." }, "load_gt_database": { "open3d.ml.tf.datasets.augment.ObjdetAugmentation": "Load ground truth object database.", "open3d.ml.torch.datasets.augment.ObjdetAugmentation": "Load ground truth object database." }, "ChromaticAutoContrast": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Improve contrast for RGB features.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Improve contrast for RGB features." }, "ChromaticJitter": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Adds a small noise jitter to features.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Adds a small noise jitter to features." }, "ChromaticTranslation": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Adds a small translation vector to features.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Adds a small translation vector to features." }, "HueSaturationTranslation": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Adds small noise to hue and saturation.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Adds small noise to hue and saturation." }, "RandomDropout": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Randomly drops some points.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Randomly drops some points." }, "RandomHorizontalFlip": { "open3d.ml.tf.datasets.augment.SemsegAugmentation": "Randomly flips the given axes.", "open3d.ml.torch.datasets.augment.SemsegAugmentation": "Randomly flips the given axes." }, "generate_corners3d": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Generate corners3d representation for this object.", "open3d.ml.torch.datasets.utils.BEVBox3D": "Generate corners3d representation for this object." }, "get_difficulty": { "open3d.ml.tf.datasets.utils.BEVBox3D": "General method to compute difficulty, can be overloaded.", "open3d.ml.torch.datasets.utils.BEVBox3D": "General method to compute difficulty, can be overloaded." }, "to_camera": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Transforms box into camera space.", "open3d.ml.torch.datasets.utils.BEVBox3D": "Transforms box into camera space." }, "to_dict": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Convert data for evaluation:", "open3d.ml.torch.datasets.utils.BEVBox3D": "Convert data for evaluation:" }, "to_dicts": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Convert data for evaluation:", "open3d.ml.torch.datasets.utils.BEVBox3D": "Convert data for evaluation:" }, "to_img": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Transforms box into 2d box.", "open3d.ml.torch.datasets.utils.BEVBox3D": "Transforms box into 2d box." }, "to_kitti_format": { "open3d.ml.tf.datasets.utils.BEVBox3D": "This method transforms the class to KITTI format.", "open3d.ml.torch.datasets.utils.BEVBox3D": "This method transforms the class to KITTI format." }, "to_xyzwhlr": { "open3d.ml.tf.datasets.utils.BEVBox3D": "Returns box in the common 7-sized vector representation: (x, y, z, w, l, h, a), where (x, y, z) is the bottom center of the box, (w, l, h) is the width, length and height of the box a is the yaw angle.", "open3d.ml.torch.datasets.utils.BEVBox3D": "Returns box in the common 7-sized vector representation: (x, y, z, w, l, h, a), where (x, y, z) is the bottom center of the box, (w, l, h) is the width, length and height of the box a is the yaw angle." }, "IoU_from_confusions": { "open3d.ml.tf.datasets.utils.DataProcessing": "Computes IoU from confusion matrices.", "open3d.ml.torch.datasets.utils.DataProcessing": "Computes IoU from confusion matrices." }, "grid_subsampling": { "open3d.ml.tf.datasets.utils.DataProcessing": "CPP wrapper for a grid subsampling (method = barycenter for points and features).", "open3d.ml.torch.datasets.utils.DataProcessing": "CPP wrapper for a grid subsampling (method = barycenter for points and features)." }, "knn_search": { "open3d.ml.tf.datasets.utils.DataProcessing": "KNN search.", "open3d.ml.torch.datasets.utils.DataProcessing": "KNN search." }, "remove_outside_points": { "open3d.ml.tf.datasets.utils.DataProcessing": "Remove points which are outside of image.", "open3d.ml.torch.datasets.utils.DataProcessing": "Remove points which are outside of image." }, "build": { "open3d.ml.tf.layers.ContinuousConv": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.FixedRadiusSearch": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.KNNSearch": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.RadiusSearch": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.SparseConv": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.SparseConvTranspose": "Creates the variables of the layer (optional, for subclass implementers).", "open3d.ml.tf.layers.VoxelPooling": "Creates the variables of the layer (optional, for subclass implementers)." }, "call": { "open3d.ml.tf.layers.ContinuousConv": "This function computes the output features.", "open3d.ml.tf.layers.FixedRadiusSearch": "This function computes the neighbors within a fixed radius for each query point.", "open3d.ml.tf.layers.KNNSearch": "This function computes the k nearest neighbors for each query point.", "open3d.ml.tf.layers.RadiusSearch": "This function computes the neighbors within a radius for each query point.", "open3d.ml.tf.layers.SparseConv": "This function computes the output features.", "open3d.ml.tf.layers.SparseConvTranspose": "This function computes the output features.", "open3d.ml.tf.layers.VoxelPooling": "This function computes the pooled positions and features.", "open3d.ml.tf.models.KPFCNN": "Calls the model on new inputs and returns the outputs as tensors.", "open3d.ml.tf.models.PVCNN": "Forward pass for the model.", "open3d.ml.tf.models.PointPillars": "Forward pass.", "open3d.ml.tf.models.PointRCNN": "Calls the model on new inputs and returns the outputs as tensors.", "open3d.ml.tf.models.PointTransformer": "Forward pass for the model.", "open3d.ml.tf.models.RandLANet": "Calls the model on new inputs and returns the outputs as tensors.", "open3d.ml.tf.models.SparseConvUnet": "Calls the model on new inputs and returns the outputs as tensors." }, "compute_output_shape": { "open3d.ml.tf.layers.ContinuousConv": "Computes the output shape of the layer.", "open3d.ml.tf.layers.SparseConv": "Computes the output shape of the layer.", "open3d.ml.tf.layers.SparseConvTranspose": "Computes the output shape of the layer." }, "big_neighborhood_filter": { "open3d.ml.tf.models.KPFCNN": "Filter neighborhoods with max number of neighbors.", "open3d.ml.torch.models.KPFCNN": "Filter neighborhoods with max number of neighbors." }, "get_batch_inds": { "open3d.ml.tf.models.KPFCNN": "Method computing the batch indices of all points, given the batch element sizes (stack lengths)." }, "get_loss": { "open3d.ml.tf.models.KPFCNN": "Runs the loss on outputs of the model.", "open3d.ml.tf.models.PVCNN": "Calculate the loss on output of the model.", "open3d.ml.tf.models.PointTransformer": "Calculate the loss on output of the model.", "open3d.ml.tf.models.RandLANet": "Calculate the loss on output of the model.", "open3d.ml.tf.models.SparseConvUnet": "Calculate the loss on output of the model.", "open3d.ml.torch.models.KPFCNN": "Runs the loss on outputs of the model.", "open3d.ml.torch.models.PVCNN": "Calculate the loss on output of the model.", "open3d.ml.torch.models.PointPillars": "Computes the loss given the network input and outputs.", "open3d.ml.torch.models.PointRCNN": "Computes the loss given the network input and outputs.", "open3d.ml.torch.models.PointTransformer": "Calculate the loss on output of the model.", "open3d.ml.torch.models.RandLANet": "Calculate the loss on output of the model.", "open3d.ml.torch.models.SparseConvUnet": "Calculate the loss on output of the model." }, "get_optimizer": { "open3d.ml.tf.models.KPFCNN": "Returns an optimizer object for the model.", "open3d.ml.tf.models.PVCNN": "Returns an optimizer object for the model.", "open3d.ml.tf.models.PointPillars": "Returns an optimizer object for the model.", "open3d.ml.tf.models.PointRCNN": "Returns an optimizer object for the model.", "open3d.ml.tf.models.PointTransformer": "Returns an optimizer object for the model.", "open3d.ml.tf.models.RandLANet": "Returns an optimizer object for the model.", "open3d.ml.tf.models.SparseConvUnet": "Returns an optimizer object for the model.", "open3d.ml.torch.models.KPFCNN": "Returns an optimizer object for the model.", "open3d.ml.torch.models.PVCNN": "Returns an optimizer object for the model.", "open3d.ml.torch.models.PointPillars": "Returns an optimizer object for the model.", "open3d.ml.torch.models.PointRCNN": "Returns an optimizer object for the model.", "open3d.ml.torch.models.PointTransformer": "Returns an optimizer object for the model.", "open3d.ml.torch.models.RandLANet": "Returns an optimizer object for the model.", "open3d.ml.torch.models.SparseConvUnet": "Returns an optimizer object for the model." }, "inference_begin": { "open3d.ml.tf.models.KPFCNN": "Function called right before running inference.", "open3d.ml.tf.models.PVCNN": "Function called right before running inference.", "open3d.ml.tf.models.PointTransformer": "Function called right before running inference.", "open3d.ml.tf.models.RandLANet": "Function called right before running inference.", "open3d.ml.tf.models.SparseConvUnet": "Function called right before running inference.", "open3d.ml.torch.models.KPFCNN": "Function called right before running inference.", "open3d.ml.torch.models.PVCNN": "Function called right before running inference.", "open3d.ml.torch.models.PointTransformer": "Function called right before running inference.", "open3d.ml.torch.models.RandLANet": "Function called right before running inference.", "open3d.ml.torch.models.SparseConvUnet": "Function called right before running inference." }, "inference_end": { "open3d.ml.tf.models.KPFCNN": "This function is called after the inference.", "open3d.ml.tf.models.PVCNN": "This function is called after the inference.", "open3d.ml.tf.models.PointPillars": "This function is called after the inference.", "open3d.ml.tf.models.PointRCNN": "This function is called after the inference.", "open3d.ml.tf.models.PointTransformer": "This function is called after the inference.", "open3d.ml.tf.models.RandLANet": "This function is called after the inference.", "open3d.ml.tf.models.SparseConvUnet": "This function is called after the inference.", "open3d.ml.torch.models.KPFCNN": "This function is called after the inference.", "open3d.ml.torch.models.PVCNN": "This function is called after the inference.", "open3d.ml.torch.models.PointPillars": "This function is called after the inference.", "open3d.ml.torch.models.PointRCNN": "This function is called after the inference.", "open3d.ml.torch.models.PointTransformer": "This function is called after the inference.", "open3d.ml.torch.models.RandLANet": "This function is called after the inference.", "open3d.ml.torch.models.SparseConvUnet": "This function is called after the inference." }, "inference_preprocess": { "open3d.ml.tf.models.KPFCNN": "This function prepares the inputs for the model.", "open3d.ml.tf.models.PVCNN": "This function prepares the inputs for the model.", "open3d.ml.tf.models.PointTransformer": "This function prepares the inputs for the model.", "open3d.ml.tf.models.RandLANet": "This function prepares the inputs for the model.", "open3d.ml.tf.models.SparseConvUnet": "This function prepares the inputs for the model.", "open3d.ml.torch.models.KPFCNN": "This function prepares the inputs for the model.", "open3d.ml.torch.models.PVCNN": "This function prepares the inputs for the model.", "open3d.ml.torch.models.PointTransformer": "This function prepares the inputs for the model.", "open3d.ml.torch.models.RandLANet": "This function prepares the inputs for the model.", "open3d.ml.torch.models.SparseConvUnet": "This function prepares the inputs for the model." }, "preprocess": { "open3d.ml.tf.models.KPFCNN": "Data preprocessing function.", "open3d.ml.tf.models.PVCNN": "Data preprocessing function.", "open3d.ml.tf.models.PointPillars": "Data preprocessing function.", "open3d.ml.tf.models.PointRCNN": "Data preprocessing function.", "open3d.ml.tf.models.PointTransformer": "Data preprocessing function.", "open3d.ml.tf.models.RandLANet": "Data preprocessing function.", "open3d.ml.tf.models.SparseConvUnet": "Data preprocessing function.", "open3d.ml.torch.models.KPFCNN": "Data preprocessing function.", "open3d.ml.torch.models.PVCNN": "Data preprocessing function.", "open3d.ml.torch.models.PointPillars": "Data preprocessing function.", "open3d.ml.torch.models.PointRCNN": "Data preprocessing function.", "open3d.ml.torch.models.PointTransformer": "Data preprocessing function.", "open3d.ml.torch.models.RandLANet": "Data preprocessing function.", "open3d.ml.torch.models.SparseConvUnet": "Data preprocessing function." }, "extract_feats": { "open3d.ml.tf.models.PointPillars": "Extract features from points.", "open3d.ml.torch.models.PointPillars": "Extract features from points." }, "loss": { "open3d.ml.tf.models.PointPillars": "Computes loss.", "open3d.ml.tf.models.PointRCNN": "Computes the loss given the network input and outputs." }, "voxelize": { "open3d.ml.tf.models.PointPillars": "Apply hard voxelization to points.", "open3d.ml.torch.models.PointPillars": "Apply hard voxelization to points." }, "filter_objects": { "open3d.ml.tf.models.PointRCNN": "Filter objects based on classes to train.", "open3d.ml.torch.models.PointRCNN": "Filter objects based on classes to train." }, "generate_rpn_training_labels": { "open3d.ml.tf.models.PointRCNN": "Generates labels for RPN network.", "open3d.ml.torch.models.PointRCNN": "Generates labels for RPN network." }, "nearest_interpolation": { "open3d.ml.tf.models.RandLANet": "feature \u2013 [B, d, N] input features matrix", "open3d.ml.torch.models.RandLANet": "feature \u2013 [B, d, N] input features matrix" }, "random_sample": { "open3d.ml.tf.models.RandLANet": "feature \u2013 [B, d, N, 1] input features matrix", "open3d.ml.torch.models.RandLANet": "feature \u2013 [B, d, N, 1] input features matrix" }, "filter_valid_label": { "open3d.ml.tf.modules.losses.SemSegLoss": "Filter out invalid points." }, "acc": { "open3d.ml.tf.modules.metrics.SemSegMetric": "Compute the per-class accuracies and the overall accuracy.", "open3d.ml.torch.modules.metrics.SemSegMetric": "Compute the per-class accuracies and the overall accuracy." }, "get_confusion_matrix": { "open3d.ml.tf.modules.metrics.SemSegMetric": "Computes the confusion matrix of one batch", "open3d.ml.torch.modules.metrics.SemSegMetric": "Computes the confusion matrix of one batch" }, "iou": { "open3d.ml.tf.modules.metrics.SemSegMetric": "Compute the per-class IoU and the mean IoU.", "open3d.ml.torch.modules.metrics.SemSegMetric": "Compute the per-class IoU and the mean IoU." }, "get_3d_summary": { "open3d.ml.tf.pipelines.ObjectDetection": "Create visualization for input point cloud and network output bounding boxes.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Create visualization for network inputs and outputs.", "open3d.ml.torch.pipelines.ObjectDetection": "Create visualization for input point cloud and network output bounding boxes.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Create visualization for network inputs and outputs." }, "run_inference": { "open3d.ml.tf.pipelines.ObjectDetection": "Run inference on given data.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Run the inference using the data passed.", "open3d.ml.torch.pipelines.ObjectDetection": "Run inference on given data.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Run inference on given data." }, "run_test": { "open3d.ml.tf.pipelines.ObjectDetection": "Run test with test data split, computes mean average precision of the prediction results.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Run the test using the data passed.", "open3d.ml.torch.pipelines.ObjectDetection": "Run test with test data split, computes mean average precision of the prediction results.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Run the test using the data passed." }, "run_train": { "open3d.ml.tf.pipelines.ObjectDetection": "Run training with train data split.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Run model training.", "open3d.ml.torch.pipelines.ObjectDetection": "Run training with train data split.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Run training on train sets." }, "run_valid": { "open3d.ml.tf.pipelines.ObjectDetection": "Run validation with validation data split, computes mean average precision and the loss of the prediction results.", "open3d.ml.torch.pipelines.ObjectDetection": "Run validation with validation data split, computes mean average precision and the loss of the prediction results." }, "save_config": { "open3d.ml.tf.pipelines.ObjectDetection": "Save experiment configuration with tensorboard summary.", "open3d.ml.tf.pipelines.SemanticSegmentation": "Save experiment configuration with tensorboard summary.", "open3d.ml.torch.pipelines.ObjectDetection": "Save experiment configuration with tensorboard summary.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Save experiment configuration with tensorboard summary." }, "load_ckpt": { "open3d.ml.tf.pipelines.SemanticSegmentation": "Load a checkpoint. You must pass the checkpoint and indicate if you want to resume.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Load a checkpoint. You must pass the checkpoint and indicate if you want to resume." }, "save_ckpt": { "open3d.ml.tf.pipelines.SemanticSegmentation": "Save a checkpoint at the passed epoch.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Save a checkpoint at the passed epoch." }, "save_logs": { "open3d.ml.tf.pipelines.SemanticSegmentation": "Save logs from the training and send results to TensorBoard.", "open3d.ml.torch.pipelines.SemanticSegmentation": "Save logs from the training and send results to TensorBoard." }, "create_lines": { "open3d.ml.tf.vis.BoundingBox3D": "Creates a LineSet that can be used to render the boxes.", "open3d.ml.torch.vis.BoundingBox3D": "Creates a LineSet that can be used to render the boxes.", "open3d.visualization.tensorboard_plugin.summary.BoundingBox3D": "Creates a LineSet that can be used to render the boxes." }, "plot_rect3d_on_img": { "open3d.ml.tf.vis.BoundingBox3D": "Plot the boundary lines of 3D rectangular on 2D images.", "open3d.ml.torch.vis.BoundingBox3D": "Plot the boundary lines of 3D rectangular on 2D images.", "open3d.visualization.tensorboard_plugin.summary.BoundingBox3D": "Plot the boundary lines of 3D rectangular on 2D images." }, "project_to_img": { "open3d.ml.tf.vis.BoundingBox3D": "Returns image with projected 3D bboxes", "open3d.ml.torch.vis.BoundingBox3D": "Returns image with projected 3D bboxes", "open3d.visualization.tensorboard_plugin.summary.BoundingBox3D": "Returns image with projected 3D bboxes" }, "calc_color_array": { "open3d.ml.tf.vis.Colormap": "Generate the color array based on the minimum and maximum range passed.", "open3d.ml.torch.vis.Colormap": "Generate the color array based on the minimum and maximum range passed." }, "calc_u_array": { "open3d.ml.tf.vis.Colormap": "Generate the basic array based on the minimum and maximum range passed.", "open3d.ml.torch.vis.Colormap": "Generate the basic array based on the minimum and maximum range passed." }, "make_greyscale": { "open3d.ml.tf.vis.Colormap": "Generate a greyscale colormap.", "open3d.ml.torch.vis.Colormap": "Generate a greyscale colormap." }, "make_rainbow": { "open3d.ml.tf.vis.Colormap": "Generate the rainbow color array.", "open3d.ml.torch.vis.Colormap": "Generate the rainbow color array." }, "unload": { "open3d.ml.tf.vis.DataModel": "Unload a pointcloud.", "open3d.ml.tf.vis.DatasetModel": "Unload the data (if it was loaded earlier).", "open3d.ml.torch.vis.DataModel": "Unload a pointcloud.", "open3d.ml.torch.vis.DatasetModel": "Unload the data (if it was loaded earlier)." }, "is_loaded": { "open3d.ml.tf.vis.DatasetModel": "Check if the data is loaded.", "open3d.ml.tf.vis.Model": "Check if the data is loaded.", "open3d.ml.torch.vis.DatasetModel": "Check if the data is loaded.", "open3d.ml.torch.vis.Model": "Check if the data is loaded." }, "add_label": { "open3d.ml.tf.vis.LabelLUT": "Adds a label to the table.", "open3d.ml.torch.vis.LabelLUT": "Adds a label to the table." }, "get_colors": { "open3d.ml.tf.vis.LabelLUT": "Return full list of colors in the lookup table.", "open3d.ml.tf.vis.Visualizer.LabelLUTEdit": "Returns a list of label keys.", "open3d.ml.torch.vis.LabelLUT": "Return full list of colors in the lookup table.", "open3d.ml.torch.vis.Visualizer.LabelLUTEdit": "Returns a list of label keys." }, "calc_bounds_for": { "open3d.ml.tf.vis.Model": "Calculate the bounds for a pointcloud.", "open3d.ml.torch.vis.Model": "Calculate the bounds for a pointcloud." }, "create_cams": { "open3d.ml.tf.vis.Model": "Create images based on the data provided.", "open3d.ml.torch.vis.Model": "Create images based on the data provided." }, "create_point_cloud": { "open3d.ml.tf.vis.Model": "Create a point cloud based on the data provided.", "open3d.ml.torch.vis.Model": "Create a point cloud based on the data provided." }, "get_attr_minmax": { "open3d.ml.tf.vis.Model": "Get the minimum and maximum for an attribute.", "open3d.ml.torch.vis.Model": "Get the minimum and maximum for an attribute." }, "get_attr_shape": { "open3d.ml.tf.vis.Model": "Get a shape from data based on the name passed.", "open3d.ml.torch.vis.Model": "Get a shape from data based on the name passed." }, "get_available_attrs": { "open3d.ml.tf.vis.Model": "Get a list of attributes based on the name.", "open3d.ml.torch.vis.Model": "Get a list of attributes based on the name." }, "update": { "open3d.ml.tf.vis.Visualizer.ColormapEdit": "Updates the colormap based on the minimum and maximum values passed.", "open3d.ml.torch.vis.Visualizer.ColormapEdit": "Updates the colormap based on the minimum and maximum values passed." }, "set_labels": { "open3d.ml.tf.vis.Visualizer.LabelLUTEdit": "Updates the labels based on look-up table passsed.", "open3d.ml.torch.vis.Visualizer.LabelLUTEdit": "Updates the labels based on look-up table passsed." }, "post_update": { "open3d.ml.tf.vis.Visualizer.ProgressDialog": "Post updates to the main thread.", "open3d.ml.torch.vis.Visualizer.ProgressDialog": "Post updates to the main thread." }, "set_text": { "open3d.ml.tf.vis.Visualizer.ProgressDialog": "Set the label text on the dialog box.", "open3d.ml.torch.vis.Visualizer.ProgressDialog": "Set the label text on the dialog box." }, "set_lut": { "open3d.ml.tf.vis.Visualizer": "Set the LUT for a specific attribute.", "open3d.ml.torch.vis.Visualizer": "Set the LUT for a specific attribute." }, "setup_camera": { "open3d.ml.tf.vis.Visualizer": "Set up camera for visualization.", "open3d.ml.torch.vis.Visualizer": "Set up camera for visualization.", "open3d.visualization.O3DVisualizer": "Overloaded function.", "open3d.visualization.gui.SceneWidget": "Overloaded function.", "open3d.visualization.rendering.OffscreenRenderer": "Overloaded function." }, "show_geometries_under": { "open3d.ml.tf.vis.Visualizer": "Show geometry for a given node.", "open3d.ml.torch.vis.Visualizer": "Show geometry for a given node." }, "visualize": { "open3d.ml.tf.vis.Visualizer": "Visualize a custom point cloud data.", "open3d.ml.torch.vis.Visualizer": "Visualize a custom point cloud data." }, "visualize_dataset": { "open3d.ml.tf.vis.Visualizer": "Visualize a dataset.", "open3d.ml.torch.vis.Visualizer": "Visualize a dataset." }, "appendleft": { "open3d.ml.tf.vis.deque": "Add an element to the left side of the deque.", "open3d.ml.torch.vis.deque": "Add an element to the left side of the deque." }, "copy": { "open3d.ml.tf.vis.deque": "Return a shallow copy of a deque.", "open3d.ml.torch.vis.deque": "Return a shallow copy of a deque." }, "extendleft": { "open3d.ml.tf.vis.deque": "Extend the left side of the deque with elements from the iterable", "open3d.ml.torch.vis.deque": "Extend the left side of the deque with elements from the iterable" }, "index": { "open3d.ml.tf.vis.deque": "Raises ValueError if the value is not present.", "open3d.ml.torch.vis.deque": "Raises ValueError if the value is not present.", "open3d.visualization.SelectedIndex": "The index of this point in the point/vertex array" }, "popleft": { "open3d.ml.tf.vis.deque": "Remove and return the leftmost element.", "open3d.ml.torch.vis.deque": "Remove and return the leftmost element." }, "reverse": { "open3d.ml.tf.vis.deque": "D.reverse () \u2013 reverse IN PLACE", "open3d.ml.torch.vis.deque": "D.reverse () \u2013 reverse IN PLACE" }, "from_row_splits": { "open3d.ml.torch.classes.RaggedTensor": "Creates a RaggedTensor with rows partitioned by row_splits." }, "to_list": { "open3d.ml.torch.classes.RaggedTensor": "Returns a list of tensors" }, "device": { "open3d.ml.torch.classes.RaggedTensor": "The device of values in this ragged tensor.", "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the device of the geometry.", "open3d.t.geometry.Geometry": "Returns the device of the geometry.", "open3d.t.geometry.Image": "Get the device of the image.", "open3d.t.geometry.LineSet": "Returns the device of the geometry.", "open3d.t.geometry.PointCloud": "Returns the device of the geometry.", "open3d.t.geometry.RGBDImage": "Returns the device of the geometry.", "open3d.t.geometry.TriangleMesh": "Returns the device of the geometry.", "open3d.t.pipelines.slac.slac_optimizer_params": "Device to use." }, "dtype": { "open3d.ml.torch.classes.RaggedTensor": "The DType of values in this ragged tensor.", "open3d.t.geometry.Image": "Get dtype of the image" }, "requires_grad": { "open3d.ml.torch.classes.RaggedTensor": "Read/writeble requires_grad for values." }, "row_splits": { "open3d.ml.torch.classes.RaggedTensor": "The row-split indices for this ragged tensor\u2019s values." }, "shape": { "open3d.ml.torch.classes.RaggedTensor": "The statically known shape of this ragged tensor." }, "values": { "open3d.ml.torch.classes.RaggedTensor": "The concatenated rows for this ragged tensor." }, "collate_fn": { "open3d.ml.torch.dataloaders.ConcatBatcher": "Collate function called by original PyTorch dataloader." }, "forward": { "open3d.ml.torch.layers.ContinuousConv": "This function computes the output features.", "open3d.ml.torch.layers.FixedRadiusSearch": "This function computes the neighbors within a fixed radius for each query point.", "open3d.ml.torch.layers.KNNSearch": "This function computes the k nearest neighbors for each query point.", "open3d.ml.torch.layers.RadiusSearch": "This function computes the neighbors within a radius for each query point.", "open3d.ml.torch.layers.SparseConv": "This function computes the output features.", "open3d.ml.torch.layers.SparseConvTranspose": "This function computes the output features.", "open3d.ml.torch.layers.VoxelPooling": "This function computes the pooled positions and features.", "open3d.ml.torch.models.KPFCNN": "Defines the computation performed at every call.", "open3d.ml.torch.models.PVCNN": "Forward pass for the model.", "open3d.ml.torch.models.PointPillars": "Defines the computation performed at every call.", "open3d.ml.torch.models.PointRCNN": "Defines the computation performed at every call.", "open3d.ml.torch.models.PointTransformer": "Forward pass for the model.", "open3d.ml.torch.models.RandLANet": "Forward pass for RandLANet", "open3d.ml.torch.models.SparseConvUnet": "Defines the computation performed at every call.", "open3d.ml.torch.modules.losses.CrossEntropyLoss": "Forward function.", "open3d.ml.torch.modules.losses.FocalLoss": "Defines the computation performed at every call.", "open3d.ml.torch.modules.losses.SmoothL1Loss": "Forward function." }, "augmentation_transform": { "open3d.ml.torch.models.KPFCNN": "Implementation of an augmentation transform for point clouds." }, "update_probs": { "open3d.ml.torch.models.RandLANet": "Update test probabilities with probs from current tested patch." }, "get_batcher": { "open3d.ml.torch.pipelines.SemanticSegmentation": "Get the batcher to be used based on the device and split." }, "update_tests": { "open3d.ml.torch.pipelines.SemanticSegmentation": "Update tests using sampler, inputs, and results." }, "extract_point_cloud": { "open3d.pipelines.integration.ScalableTSDFVolume": "Function to extract a point cloud with normals", "open3d.pipelines.integration.TSDFVolume": "Function to extract a point cloud with normals", "open3d.pipelines.integration.UniformTSDFVolume": "Function to extract a point cloud with normals", "open3d.t.geometry.VoxelBlockGrid": "Specific operation for TSDF volumes.Extract point cloud at isosurface points." }, "extract_voxel_point_cloud": { "open3d.pipelines.integration.ScalableTSDFVolume": "Debug function to extract the voxel data into a point cloud.", "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to extract the voxel data into a point cloud." }, "integrate": { "open3d.pipelines.integration.ScalableTSDFVolume": "Function to integrate an RGB-D image into the volume", "open3d.pipelines.integration.TSDFVolume": "Function to integrate an RGB-D image into the volume", "open3d.pipelines.integration.UniformTSDFVolume": "Function to integrate an RGB-D image into the volume", "open3d.t.geometry.VoxelBlockGrid": "Overloaded function.", "open3d.t.pipelines.slam.Model": "Integrate an input frame to a volume." }, "reset": { "open3d.pipelines.integration.ScalableTSDFVolume": "Function to reset the TSDFVolume", "open3d.pipelines.integration.TSDFVolume": "Function to reset the TSDFVolume", "open3d.pipelines.integration.UniformTSDFVolume": "Function to reset the TSDFVolume" }, "color_type": { "open3d.pipelines.integration.ScalableTSDFVolume": "Color type of the TSDF volume.", "open3d.pipelines.integration.TSDFVolume": "Color type of the TSDF volume.", "open3d.pipelines.integration.UniformTSDFVolume": "Color type of the TSDF volume." }, "sdf_trunc": { "open3d.pipelines.integration.ScalableTSDFVolume": "Truncation value for signed distance function (SDF).", "open3d.pipelines.integration.TSDFVolume": "Truncation value for signed distance function (SDF).", "open3d.pipelines.integration.UniformTSDFVolume": "Truncation value for signed distance function (SDF)." }, "voxel_length": { "open3d.pipelines.integration.ScalableTSDFVolume": "Length of the voxel in meters.", "open3d.pipelines.integration.TSDFVolume": "Length of the voxel in meters.", "open3d.pipelines.integration.UniformTSDFVolume": "Length of the voxel in meters." }, "extract_volume_color": { "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to extract the volume color data." }, "extract_volume_tsdf": { "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to extract the volume TSDF data." }, "extract_voxel_grid": { "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to extract the voxel data VoxelGrid." }, "inject_volume_color": { "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to inject the voxel Color data." }, "inject_volume_tsdf": { "open3d.pipelines.integration.UniformTSDFVolume": "Debug function to inject the voxel TSDF data." }, "length": { "open3d.pipelines.integration.UniformTSDFVolume": "Total length, where voxel_length = length / resolution." }, "resolution": { "open3d.pipelines.integration.UniformTSDFVolume": "Resolution over the total length, where voxel_length = length / resolution" }, "depth_diff_max": { "open3d.pipelines.odometry.OdometryOption": "Maximum depth difference to be considered as correspondence. In depth image domain, if two aligned pixels have a depth difference less than specified value, they are considered as a correspondence. Larger value induce more aggressive search, but it is prone to unstable result." }, "depth_max": { "open3d.pipelines.odometry.OdometryOption": "Pixels that has larger than specified depth values are ignored." }, "depth_min": { "open3d.pipelines.odometry.OdometryOption": "Pixels that has smaller than specified depth values are ignored." }, "iteration_number_per_pyramid_level": { "open3d.pipelines.odometry.OdometryOption": "Iteration number per image pyramid level, typically larger image in the pyramid have lower iteration number to reduce computation time." }, "weight": { "open3d.pipelines.registration.CauchyLoss": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.GMLoss": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.HuberLoss": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.L1Loss": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.L2Loss": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.RobustKernel": "Obtain the weight for the given residual according to the robust kernel model.", "open3d.pipelines.registration.TukeyLoss": "Obtain the weight for the given residual according to the robust kernel model." }, "k": { "open3d.pipelines.registration.CauchyLoss": "Parameter of the loss.", "open3d.pipelines.registration.GMLoss": "Parameter of the loss.", "open3d.pipelines.registration.HuberLoss": "Parameter of the loss", "open3d.pipelines.registration.TukeyLoss": "k Is a running constant for the loss." }, "Check": { "open3d.pipelines.registration.CorrespondenceChecker": "Function to check if two points can be aligned. The two input point clouds must have exact the same number of points.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance": "Function to check if two points can be aligned. The two input point clouds must have exact the same number of points.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength": "Function to check if two points can be aligned. The two input point clouds must have exact the same number of points.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnNormal": "Function to check if two points can be aligned. The two input point clouds must have exact the same number of points." }, "require_pointcloud_alignment_": { "open3d.pipelines.registration.CorrespondenceChecker": "Some checkers do not require point clouds to be aligned, e.g., the edge length checker. Some checkers do, e.g., the distance checker.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance": "Some checkers do not require point clouds to be aligned, e.g., the edge length checker. Some checkers do, e.g., the distance checker.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength": "Some checkers do not require point clouds to be aligned, e.g., the edge length checker. Some checkers do, e.g., the distance checker.", "open3d.pipelines.registration.CorrespondenceCheckerBasedOnNormal": "Some checkers do not require point clouds to be aligned, e.g., the edge length checker. Some checkers do, e.g., the distance checker." }, "distance_threshold": { "open3d.pipelines.registration.CorrespondenceCheckerBasedOnDistance": "Distance threshold for the check.", "open3d.t.pipelines.slac.slac_optimizer_params": "Distance threshold to filter inconsistent correspondences." }, "similarity_threshold": { "open3d.pipelines.registration.CorrespondenceCheckerBasedOnEdgeLength": "For the check to be true," }, "normal_angle_threshold": { "open3d.pipelines.registration.CorrespondenceCheckerBasedOnNormal": "Radian value for angle threshold." }, "decrease_mu": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Set to True to decrease scale mu by division_factor for graduated non-convexity." }, "division_factor": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Division factor used for graduated non-convexity." }, "iteration_number": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Maximum number of iterations." }, "maximum_correspondence_distance": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Maximum correspondence distance." }, "maximum_tuple_count": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Maximum tuple numbers." }, "tuple_scale": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Similarity measure used for tuples of feature points." }, "tuple_test": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Set to true to perform geometric compatibility tests on initial set of correspondences." }, "use_absolute_scale": { "open3d.pipelines.registration.FastGlobalRegistrationOption": "Measure distance in absolute scale (1) or in scale relative to the diameter of the model (0)." }, "num": { "open3d.pipelines.registration.Feature": "Returns number of points." }, "resize": { "open3d.pipelines.registration.Feature": "Resize feature data buffer to dim x n.", "open3d.t.geometry.Image": "Return a new image after resizing with specified interpolation type. Downsample if sampling rate is < 1. Upsample if sampling rate > 1. Aspect ratio is always kept." }, "data": { "open3d.pipelines.registration.Feature": "Data buffer storing features." }, "lower_scale_factor": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Lower scale factor value." }, "max_iteration": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Maximum iteration number for iterative optimization module.", "open3d.pipelines.registration.ICPConvergenceCriteria": "Maximum iteration before iteration stops.", "open3d.pipelines.registration.RANSACConvergenceCriteria": "Maximum iteration before iteration stops.", "open3d.t.pipelines.odometry.OdometryConvergenceCriteria": "Maximum iteration before iteration stops.", "open3d.t.pipelines.registration.ICPConvergenceCriteria": "Maximum iteration before iteration stops." }, "max_iteration_lm": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Maximum iteration number for Levenberg Marquardt method. max_iteration_lm is used for additional Levenberg-Marquardt inner loop that automatically changes steepest gradient gain." }, "min_relative_increment": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Minimum relative increments." }, "min_relative_residual_increment": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Minimum relative residual increments." }, "min_residual": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Minimum residual value." }, "min_right_term": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Minimum right term value." }, "upper_scale_factor": { "open3d.pipelines.registration.GlobalOptimizationConvergenceCriteria": "Upper scale factor value. Scaling factors are used for levenberg marquardt algorithm these are scaling factors that increase/decrease lambda used in H_LM = H + lambda * I" }, "OptimizePoseGraph": { "open3d.pipelines.registration.GlobalOptimizationGaussNewton": "Run pose graph optimization.", "open3d.pipelines.registration.GlobalOptimizationLevenbergMarquardt": "Run pose graph optimization.", "open3d.pipelines.registration.GlobalOptimizationMethod": "Run pose graph optimization." }, "edge_prune_threshold": { "open3d.pipelines.registration.GlobalOptimizationOption": "According to [Choi et al 2015], line_process weight < edge_prune_threshold (0.25) is pruned." }, "max_correspondence_distance": { "open3d.pipelines.registration.GlobalOptimizationOption": "Identifies which distance value is used for finding neighboring points when making information matrix. According to [Choi et al 2015], this distance is used for determining $mu, a line process weight." }, "preference_loop_closure": { "open3d.pipelines.registration.GlobalOptimizationOption": "odometry vs loop-closure. [0,1] -> try to unchange odometry edges, [1) -> try to utilize loop-closure. Recommendation: 0.1 for RGBD Odometry, 2.0 for fragment registration." }, "reference_node": { "open3d.pipelines.registration.GlobalOptimizationOption": "The pose of this node is unchanged after optimization." }, "relative_fitness": { "open3d.pipelines.registration.ICPConvergenceCriteria": "If relative change (difference) of fitness score is lower than relative_fitness, the iteration stops.", "open3d.t.pipelines.odometry.OdometryConvergenceCriteria": "If relative change (difference) of fitness score is lower than relative_fitness, the iteration stops.", "open3d.t.pipelines.registration.ICPConvergenceCriteria": "If relative change (difference) of fitness score is lower than relative_fitness, the iteration stops." }, "relative_rmse": { "open3d.pipelines.registration.ICPConvergenceCriteria": "If relative change (difference) of inliner RMSE score is lower than relative_rmse, the iteration stops.", "open3d.t.pipelines.odometry.OdometryConvergenceCriteria": "If relative change (difference) of inliner RMSE score is lower than relative_rmse, the iteration stops.", "open3d.t.pipelines.registration.ICPConvergenceCriteria": "If relative change (difference) of inlier RMSE score is lower than relative_rmse, the iteration stops." }, "edges": { "open3d.pipelines.registration.PoseGraph": "List of PoseGraphEdge." }, "nodes": { "open3d.pipelines.registration.PoseGraph": "List of PoseGraphNode." }, "confidence": { "open3d.pipelines.registration.PoseGraphEdge": "Confidence value of the edge. if uncertain is true, it has confidence bounded in [0,1]. 1 means reliable, and 0 means unreliable edge. This correspondence to line process value in [Choi et al 2015] See core/registration/globaloptimization.h for more details.", "open3d.pipelines.registration.RANSACConvergenceCriteria": "Desired probability of success. Used for estimating early termination. Use 1.0 to avoid early termination." }, "information": { "open3d.pipelines.registration.PoseGraphEdge": "Information matrix." }, "source_node_id": { "open3d.pipelines.registration.PoseGraphEdge": "Source PoseGraphNode id." }, "target_node_id": { "open3d.pipelines.registration.PoseGraphEdge": "Target PoseGraphNode id." }, "transformation": { "open3d.pipelines.registration.PoseGraphEdge": "Transformation matrix.", "open3d.pipelines.registration.RegistrationResult": "The estimated transformation matrix.", "open3d.t.pipelines.odometry.OdometryResult": "The estimated transformation matrix.", "open3d.t.pipelines.registration.RegistrationResult": "The estimated transformation matrix." }, "uncertain": { "open3d.pipelines.registration.PoseGraphEdge": "Whether the edge is uncertain. Odometry edge has uncertain == false, loop closure edges has uncertain == true" }, "correspondence_set": { "open3d.pipelines.registration.RegistrationResult": "Correspondence set between source and target point cloud." }, "fitness": { "open3d.pipelines.registration.RegistrationResult": "The overlapping area (# of inlier correspondences / # of points in source). Higher is better.", "open3d.t.pipelines.odometry.OdometryResult": "The overlapping area (# of inlier correspondences / # of points in target). Higher is better.", "open3d.t.pipelines.registration.RegistrationResult": "The overlapping area (# of inlier correspondences / # of points in source). Higher is better." }, "inlier_rmse": { "open3d.pipelines.registration.RegistrationResult": "RMSE of all inlier correspondences. Lower is better.", "open3d.t.pipelines.odometry.OdometryResult": "RMSE of all inlier correspondences. Lower is better.", "open3d.t.pipelines.registration.RegistrationResult": "RMSE of all inlier correspondences. Lower is better." }, "compute_rmse": { "open3d.pipelines.registration.TransformationEstimation": "Compute RMSE between source and target points cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationForColoredICP": "Compute RMSE between source and target points cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationForGeneralizedICP": "Compute RMSE between source and target points cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationPointToPlane": "Compute RMSE between source and target points cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationPointToPoint": "Compute RMSE between source and target points cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimation": "Compute RMSE between source and target points cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationForColoredICP": "Compute RMSE between source and target points cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationPointToPlane": "Compute RMSE between source and target points cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationPointToPoint": "Compute RMSE between source and target points cloud given correspondences." }, "compute_transformation": { "open3d.pipelines.registration.TransformationEstimation": "Compute transformation from source to target point cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationForColoredICP": "Compute transformation from source to target point cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationForGeneralizedICP": "Compute transformation from source to target point cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationPointToPlane": "Compute transformation from source to target point cloud given correspondences.", "open3d.pipelines.registration.TransformationEstimationPointToPoint": "Compute transformation from source to target point cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimation": "Compute transformation from source to target point cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationForColoredICP": "Compute transformation from source to target point cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationPointToPlane": "Compute transformation from source to target point cloud given correspondences.", "open3d.t.pipelines.registration.TransformationEstimationPointToPoint": "Compute transformation from source to target point cloud given correspondences." }, "kernel": { "open3d.pipelines.registration.TransformationEstimationForColoredICP": "Robust Kernel used in the Optimization", "open3d.pipelines.registration.TransformationEstimationForGeneralizedICP": "Robust Kernel used in the Optimization", "open3d.pipelines.registration.TransformationEstimationPointToPlane": "Robust Kernel used in the Optimization", "open3d.t.pipelines.registration.TransformationEstimationForColoredICP": "Robust Kernel used in the Optimization", "open3d.t.pipelines.registration.TransformationEstimationPointToPlane": "Robust Kernel used in the Optimization" }, "with_scaling": { "open3d.pipelines.registration.TransformationEstimationPointToPoint": "Set to True to estimate scaling, False to force scaling to be 1." }, "from_legacy": { "open3d.t.geometry.AxisAlignedBoundingBox": "Create an AxisAlignedBoundingBox from a legacy Open3D axis-aligned box.", "open3d.t.geometry.Image": "Create a Image from a legacy Open3D Image.", "open3d.t.geometry.LineSet": "Create a LineSet from a legacy Open3D LineSet.", "open3d.t.geometry.PointCloud": "Create a PointCloud from a legacy Open3D PointCloud.", "open3d.t.geometry.TriangleMesh": "Create a TriangleMesh from a legacy Open3D TriangleMesh." }, "get_color": { "open3d.t.geometry.AxisAlignedBoundingBox": "Returns the color for box." }, "has_valid_material": { "open3d.t.geometry.AxisAlignedBoundingBox": "Returns true if the geometry\u2019s material is valid.", "open3d.t.geometry.DrawableGeometry": "Returns true if the geometry\u2019s material is valid.", "open3d.t.geometry.LineSet": "Returns true if the geometry\u2019s material is valid.", "open3d.t.geometry.PointCloud": "Returns true if the geometry\u2019s material is valid.", "open3d.t.geometry.TriangleMesh": "Returns true if the geometry\u2019s material is valid." }, "set_color": { "open3d.t.geometry.AxisAlignedBoundingBox": "Set the color of the axis-aligned box.", "open3d.visualization.gui.Color": "Sets red, green, blue, and alpha channels, (range: [0.0, 1.0])" }, "set_max_bound": { "open3d.t.geometry.AxisAlignedBoundingBox": "Set the upper bound of the axis-aligned box." }, "set_min_bound": { "open3d.t.geometry.AxisAlignedBoundingBox": "Set the lower bound of the axis-aligned box." }, "to_legacy": { "open3d.t.geometry.AxisAlignedBoundingBox": "Convert to a legacy Open3D axis-aligned box.", "open3d.t.geometry.Image": "Convert to legacy Image type.", "open3d.t.geometry.LineSet": "Convert to a legacy Open3D LineSet.", "open3d.t.geometry.PointCloud": "Convert to a legacy Open3D PointCloud.", "open3d.t.geometry.RGBDImage": "Convert to legacy RGBDImage type.", "open3d.t.geometry.TriangleMesh": "Convert to a legacy Open3D TriangleMesh." }, "is_cpu": { "open3d.t.geometry.AxisAlignedBoundingBox": "Returns true if the geometry is on CPU.", "open3d.t.geometry.Geometry": "Returns true if the geometry is on CPU.", "open3d.t.geometry.Image": "Returns true if the geometry is on CPU.", "open3d.t.geometry.LineSet": "Returns true if the geometry is on CPU.", "open3d.t.geometry.PointCloud": "Returns true if the geometry is on CPU.", "open3d.t.geometry.RGBDImage": "Returns true if the geometry is on CPU.", "open3d.t.geometry.TriangleMesh": "Returns true if the geometry is on CPU." }, "is_cuda": { "open3d.t.geometry.AxisAlignedBoundingBox": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.Geometry": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.Image": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.LineSet": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.PointCloud": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.RGBDImage": "Returns true if the geometry is on CUDA.", "open3d.t.geometry.TriangleMesh": "Returns true if the geometry is on CUDA." }, "clip_transform": { "open3d.t.geometry.Image": "Preprocess a image of shape (rows, cols, channels=1), typically used for a depth image. UInt16 and Float32 Dtypes supported. Each pixel will be transformed by x = x / scale x = x < min_value ? clip_fill : x x = x > max_value ? clip_fill : x Use INF, NAN or 0.0 (default) for clip_fill" }, "colorize_depth": { "open3d.t.geometry.Image": "Colorize an input depth image (with Dtype UInt16 or Float32). The image values are divided by scale, then clamped within (min_value, max_value) and finally converted to a 3 channel UInt8 RGB image using the Turbo colormap as a lookup table." }, "create_normal_map": { "open3d.t.geometry.Image": "Create a normal map of shape (rows, cols, channels=3) in Float32 from a vertex map of shape (rows, cols, channels=1) in Float32 using cross product of V (r, c+1)-V (r, c) and V (r+1, c)-V (r, c). The input vertex map is expected to be the output of create_vertex_map. You may need to start with a filtered depth image (e.g. with filter_bilateral) to obtain good results." }, "create_vertex_map": { "open3d.t.geometry.Image": "Create a vertex map of shape (rows, cols, channels=3) in Float32 from an image of shape (rows, cols, channels=1) in Float32 using unprojection. The input depth is expected to be the output of clip_transform." }, "dilate": { "open3d.t.geometry.Image": "Return a new image after performing morphological dilation. Supported datatypes are UInt8, UInt16 and Float32 with {1, 3, 4} channels. An 8-connected neighborhood is used to create the dilation mask." }, "filter_bilateral": { "open3d.t.geometry.Image": "Return a new image after bilateral filtering.Note: CPU (IPP) and CUDA (NPP) versions are inconsistent: CPU uses a round kernel (radius = floor (kernel_size / 2)), while CUDA uses a square kernel (width = kernel_size). Make sure to tune parameters accordingly." }, "filter_gaussian": { "open3d.t.geometry.Image": "Return a new image after Gaussian filtering. Possible kernel_size: odd numbers >= 3 are supported." }, "filter_sobel": { "open3d.t.geometry.Image": "Return a pair of new gradient images (dx, dy) after Sobel filtering. Possible kernel_size: 3 and 5." }, "linear_transform": { "open3d.t.geometry.Image": "Function to linearly transform pixel intensities in place: image = scale * image + offset." }, "pyrdown": { "open3d.t.geometry.Image": "Return a new downsampled image with pyramid downsampling formed by a chained Gaussian filter (kernel_size = 5, sigma = 1.0) and a resize (ratio = 0.5) operation." }, "rgb_to_gray": { "open3d.t.geometry.Image": "Converts a 3-channel RGB image to a new 1-channel Grayscale image by I = 0.299 * R + 0.587 * G + 0.114 * B." }, "channels": { "open3d.t.geometry.Image": "Get the number of channels of the image." }, "columns": { "open3d.t.geometry.Image": "Get the number of columns of the image." }, "rows": { "open3d.t.geometry.Image": "Get the number of rows of the image." }, "extrude_linear": { "open3d.t.geometry.LineSet": "Sweeps the line set along a direction vector.", "open3d.t.geometry.PointCloud": "Sweeps the point cloud along a direction vector.", "open3d.t.geometry.TriangleMesh": "Sweeps the line set along a direction vector. :param vector: The direction vector. :type vector: open3d.core.Tensor :param scale: Scalar factor which essentially scales the direction vector. :type scale: float" }, "extrude_rotation": { "open3d.t.geometry.LineSet": "Sweeps the line set rotationally about an axis.", "open3d.t.geometry.PointCloud": "Sweeps the point set rotationally about an axis.", "open3d.t.geometry.TriangleMesh": "Sweeps the triangle mesh rotationally about an axis. :param angle: The rotation angle in degree. :type angle: float :param axis: The rotation axis. :type axis: open3d.core.Tensor :param resolution: The resolution defines the number of intermediate sweeps" }, "line": { "open3d.t.geometry.LineSet": "Dictionary containing line attributes. The primary key indices contains indices of points defining the lines." }, "point": { "open3d.t.geometry.LineSet": "Dictionary containing point attributes. The primary key positions contains point positions.", "open3d.t.geometry.PointCloud": "positions, colors, normals, etc.", "open3d.visualization.SelectedIndex": "The (x, y, z) value of this point" }, "compute_boundary_points": { "open3d.t.geometry.PointCloud": "Compute the boundary points of a point cloud. The implementation is inspired by the PCL implementation. Reference: __URL__" }, "estimate_color_gradients": { "open3d.t.geometry.PointCloud": "Function to estimate point color gradients. It uses KNN search (Not recommended to use on GPU) if only max_nn parameter is provided, Radius search (Not recommended to use on GPU) if only radius is provided and Hybrid Search (Recommended) if radius parameter is also provided." }, "project_to_depth_image": { "open3d.t.geometry.PointCloud": "[0.0 1.0 0.0 0.0], [0.0 0.0 1.0 0.0], [0.0 0.0 0.0 1.0]]" }, "project_to_rgbd_image": { "open3d.t.geometry.PointCloud": "[0.0 1.0 0.0 0.0], [0.0 0.0 1.0 0.0], [0.0 0.0 0.0 1.0]]" }, "remove_radius_outliers": { "open3d.t.geometry.PointCloud": "Remove points that have less than nb_points neighbors in a sphere of a given search radius." }, "select_by_mask": { "open3d.t.geometry.PointCloud": "Select points from input pointcloud, based on boolean mask indices into output point cloud." }, "are_aligned": { "open3d.t.geometry.RGBDImage": "Are the depth and color images aligned (same viewpoint and resolution)?" }, "aligned_": { "open3d.t.geometry.RGBDImage": "Are the depth and color images aligned (same viewpoint and resolution)?" }, "add_triangles": { "open3d.t.geometry.RaycastingScene": "Overloaded function." }, "cast_rays": { "open3d.t.geometry.RaycastingScene": "Computes the first intersection of the rays with the scene." }, "compute_closest_points": { "open3d.t.geometry.RaycastingScene": "Computes the closest points on the surfaces of the scene." }, "compute_distance": { "open3d.t.geometry.RaycastingScene": "Computes the distance to the surface of the scene." }, "compute_occupancy": { "open3d.t.geometry.RaycastingScene": "Computes the occupancy at the query point positions." }, "compute_signed_distance": { "open3d.t.geometry.RaycastingScene": "Computes the signed distance to the surface of the scene." }, "count_intersections": { "open3d.t.geometry.RaycastingScene": "Computes the number of intersection of the rays with the scene." }, "create_rays_pinhole": { "open3d.t.geometry.RaycastingScene": "Overloaded function." }, "test_occlusions": { "open3d.t.geometry.RaycastingScene": "Checks if the rays have any intersection with the scene." }, "bake_triangle_attr_textures": { "open3d.t.geometry.TriangleMesh": "Bake triangle attributes into textures." }, "bake_vertex_attr_textures": { "open3d.t.geometry.TriangleMesh": "Bake vertex attributes into textures." }, "boolean_difference": { "open3d.t.geometry.TriangleMesh": "Computes the mesh that encompasses the volume after subtracting the volume of the second operand. Both meshes should be manifold." }, "boolean_intersection": { "open3d.t.geometry.TriangleMesh": "Computes the mesh that encompasses the intersection of the volumes of two meshes. Both meshes should be manifold." }, "boolean_union": { "open3d.t.geometry.TriangleMesh": "Computes the mesh that encompasses the union of the volumes of two meshes. Both meshes should be manifold." }, "clip_plane": { "open3d.t.geometry.TriangleMesh": "Returns a new triangle mesh clipped with the plane." }, "compute_uvatlas": { "open3d.t.geometry.TriangleMesh": "Creates an UV atlas and adds it as triangle attr \u2018texture_uvs\u2019 to the mesh." }, "create_text": { "open3d.t.geometry.TriangleMesh": "Create a triangle mesh from a text string." }, "fill_holes": { "open3d.t.geometry.TriangleMesh": "Fill holes by triangulating boundary edges." }, "slice_plane": { "open3d.t.geometry.TriangleMesh": "Returns a line set with the contour slices defined by the plane and values." }, "attribute": { "open3d.t.geometry.VoxelBlockGrid": "Get the attribute tensor to be indexed with voxel_indices." }, "compute_unique_block_coordinates": { "open3d.t.geometry.VoxelBlockGrid": "Overloaded function." }, "hashmap": { "open3d.t.geometry.VoxelBlockGrid": "Get the underlying hash map from 3d block coordinates to block voxel grids." }, "ray_cast": { "open3d.t.geometry.VoxelBlockGrid": "Specific operation for TSDF volumes.Perform volumetric ray casting in the selected block coordinates.The block coordinates in the frustum can be taken fromcompute_unique_block_coordinatesAll the block coordinates can be taken from hashmap ().key_tensor ()" }, "voxel_coordinates": { "open3d.t.geometry.VoxelBlockGrid": "Get a (3, hashmap.Size () * resolution^3) coordinate tensor of activevoxels per block, used for geometry transformation jointly with indices from voxel_indices. Example: For a voxel block grid with (2, 2, 2) block resolution, if the active block coordinates are { (-1, 3, 2), (0, 2, 4)}, the returned result will be a (3, 2 x 8) tensor given by: { key_tensor[voxel_indices[0]] * block_resolution_ + voxel_indices[1] key_tensor[voxel_indices[0]] * block_resolution_ + voxel_indices[2] key_tensor[voxel_indices[0]] * block_resolution_ + voxel_indices[3] } Note: the coordinates are VOXEL COORDINATES in Int64. To access metriccoordinates, multiply by voxel size." }, "voxel_coordinates_and_flattened_indices": { "open3d.t.geometry.VoxelBlockGrid": "Overloaded function." }, "voxel_indices": { "open3d.t.geometry.VoxelBlockGrid": "Overloaded function." }, "enable_deterministic_debug_mode": { "open3d.t.io.DepthNoiseSimulator": "Enable deterministic debug mode. All normally distributed noise will be replaced by 0." }, "simulate": { "open3d.t.io.DepthNoiseSimulator": "Apply noise model to a depth image." }, "noise_model": { "open3d.t.io.DepthNoiseSimulator": "The noise model tensor." }, "color_channels": { "open3d.t.io.RGBDVideoMetadata": "Number of color channels." }, "color_dt": { "open3d.t.io.RGBDVideoMetadata": "Pixel Dtype for color data." }, "color_format": { "open3d.t.io.RGBDVideoMetadata": "Pixel format for color data" }, "depth_dt": { "open3d.t.io.RGBDVideoMetadata": "Pixel Dtype for depth data." }, "depth_format": { "open3d.t.io.RGBDVideoMetadata": "Pixel format for depth data" }, "depth_scale": { "open3d.t.io.RGBDVideoMetadata": "Number of depth units per meter (depth in m = depth_pixel_value/depth_scale)." }, "device_name": { "open3d.t.io.RGBDVideoMetadata": "Capture device name" }, "fps": { "open3d.t.io.RGBDVideoMetadata": "Video frame rate (common for both color and depth)" }, "intrinsics": { "open3d.t.io.RGBDVideoMetadata": "Shared intrinsics between RGB & depth" }, "serial_number": { "open3d.t.io.RGBDVideoMetadata": "Capture device serial number" }, "create": { "open3d.t.io.RGBDVideoReader": "Create RGBD video reader based on filename", "open3d.t.io.RSBagReader": "Create RGBD video reader based on filename" }, "save_frames": { "open3d.t.io.RGBDVideoReader": "Save synchronized and aligned individual frames to subfolders.", "open3d.t.io.RSBagReader": "Save synchronized and aligned individual frames to subfolders." }, "get_timestamp": { "open3d.t.io.RSBagReader": "Get current timestamp (in us).", "open3d.t.io.RealSenseSensor": "Get current timestamp (in us)" }, "metadata": { "open3d.t.io.RSBagReader": "Get metadata of the RS bag playback." }, "enumerate_devices": { "open3d.t.io.RealSenseSensor": "Query all connected RealSense cameras for their capabilities." }, "get_filename": { "open3d.t.io.RealSenseSensor": "Get filename being written." }, "pause_record": { "open3d.t.io.RealSenseSensor": "Pause recording to the bag file. Note: If this is called immediately after start_capture, the bag file may have an incorrect end time." }, "resume_record": { "open3d.t.io.RealSenseSensor": "Resume recording to the bag file. The file will contain discontinuous segments." }, "start_capture": { "open3d.t.io.RealSenseSensor": "Start capturing synchronized depth and color frames." }, "stop_capture": { "open3d.t.io.RealSenseSensor": "Stop capturing frames." }, "name": { "open3d.t.io.RealSenseValidConfigs": "Device name.", "open3d.visualization.O3DVisualizer.DrawObject": "The name of the object" }, "serial": { "open3d.t.io.RealSenseValidConfigs": "Device serial number." }, "valid_configs": { "open3d.t.io.RealSenseValidConfigs": "Mapping between configuration option name and a list of valid values." }, "depth_huber_delta": { "open3d.t.pipelines.odometry.OdometryLossParams": "Huber norm parameter used in depth loss." }, "depth_outlier_trunc": { "open3d.t.pipelines.odometry.OdometryLossParams": "Depth difference threshold used to filter projective associations." }, "intensity_huber_delta": { "open3d.t.pipelines.odometry.OdometryLossParams": "Huber norm parameter used in intensity loss." }, "correspondences_": { "open3d.t.pipelines.registration.RegistrationResult": "Tensor of type Int64 containing indices of corresponding target points, where the value is the target index and the index of the value itself is the source index. It contains -1 as value at index with no correspondence." }, "compactify": { "open3d.t.pipelines.slac.control_grid": "Force rehashing, so that all entries are remapped to [0, size) and form a contiguous index map." }, "deform": { "open3d.t.pipelines.slac.control_grid": "Overloaded function." }, "get_curr_positions": { "open3d.t.pipelines.slac.control_grid": "Get control grid shifted positions from tensor values (optimized in-place)" }, "get_hashmap": { "open3d.t.pipelines.slac.control_grid": "Get the control grid hashmap.", "open3d.t.pipelines.slam.Model": "Get the underlying hash map from 3D coordinates to voxel blocks." }, "get_init_positions": { "open3d.t.pipelines.slac.control_grid": "Get control grid original positions directly from tensor keys." }, "get_neighbor_grid_map": { "open3d.t.pipelines.slac.control_grid": "buf_indices Active indices in the buffer of shape (N, )" }, "parameterize": { "open3d.t.pipelines.slac.control_grid": "Parameterize an input point cloud by embedding each point in the grid with 8 corners via indexing and interpolation. Returns: A PointCloud with parameterization attributes: - neighbors: Index of 8 neighbor control grid points of shape (8, ) in Int64. - ratios: Interpolation ratios of 8 neighbor control grid points of shape (8, ) in Float32." }, "touch": { "open3d.t.pipelines.slac.control_grid": "Allocate control grids in the shared camera space." }, "debug": { "open3d.t.pipelines.slac.slac_debug_option": "Enable debug." }, "debug_start_node_idx": { "open3d.t.pipelines.slac.slac_debug_option": "The node id to start debugging with. Smaller nodes will be skipped for visualization." }, "get_subfolder_name": { "open3d.t.pipelines.slac.slac_optimizer_params": "Relative directory to store SLAC results in the dataset folder." }, "fitness_threshold": { "open3d.t.pipelines.slac.slac_optimizer_params": "Fitness threshold to filter inconsistent pairs." }, "max_iterations": { "open3d.t.pipelines.slac.slac_optimizer_params": "Number of iterations." }, "regularizer_weight": { "open3d.t.pipelines.slac.slac_optimizer_params": "Weight of the regularizer." }, "slac_folder": { "open3d.t.pipelines.slac.slac_optimizer_params": "Relative directory to store SLAC results in the dataset folder." }, "get_data_as_image": { "open3d.t.pipelines.slam.Frame": "Get a 2D image from from the given key in the map." }, "set_data": { "open3d.t.pipelines.slam.Frame": "Set a 2D tensor to a image to the given key in the map." }, "set_data_from_image": { "open3d.t.pipelines.slam.Frame": "Set a 2D image to the given key in the map." }, "extract_pointcloud": { "open3d.t.pipelines.slam.Model": "Extract point cloud from the volumetric model." }, "extract_trianglemesh": { "open3d.t.pipelines.slam.Model": "Extract triangle mesh from the volumetric model." }, "synthesize_model_frame": { "open3d.t.pipelines.slam.Model": "Synthesize frame from the volumetric model using ray casting." }, "track_frame_to_model": { "open3d.t.pipelines.slam.Model": "Track input frame against raycasted frame from model." }, "frame_id": { "open3d.t.pipelines.slam.Model": "Get the current frame index in a sequence." }, "frustum_block_coords": { "open3d.t.pipelines.slam.Model": "Active block coordinates from prior integration" }, "transformation_frame_to_world": { "open3d.t.pipelines.slam.Model": "Get the 4x4 transformation matrix from the current frame to the world frame." }, "voxel_grid": { "open3d.t.pipelines.slam.Model": "Get the maintained VoxelBlockGrid." }, "draw": { "open3d.visualization.ExternalVisualizer": "This function has the same functionality as \u2018set\u2019." }, "set": { "open3d.visualization.ExternalVisualizer": "Send Open3D objects for visualization to the visualizer." }, "set_active_camera": { "open3d.visualization.ExternalVisualizer": "Sets the active camera in the external visualizer", "open3d.visualization.rendering.Scene": "Sets the camera with the given name as the active camera for the scene" }, "set_time": { "open3d.visualization.ExternalVisualizer": "Sets the time in the external visualizer" }, "set_default_properties": { "open3d.visualization.Material": "Fills material with defaults for common PBR material properties used by Open3D" }, "geometry": { "open3d.visualization.O3DVisualizer.DrawObject": "The geometry. Modifying this will not result in any visible change. Use remove_geometry () and then add_geometry ()to change the geometry" }, "group": { "open3d.visualization.O3DVisualizer.DrawObject": "The group that the object belongs to" }, "is_visible": { "open3d.visualization.O3DVisualizer.DrawObject": "True if the object is checked in the list. If the object\u2019s group is unchecked or an animation is playing, the object\u2019s visibility may not correspond with this value", "open3d.visualization.gui.Window": "True if window is visible (read-only)" }, "time": { "open3d.visualization.O3DVisualizer.DrawObject": "The object\u2019s timestamp" }, "add_3d_label": { "open3d.visualization.O3DVisualizer": "add_3d_label ([x,y,z], text): displays text anchored at the 3D coordinate specified", "open3d.visualization.gui.SceneWidget": "Add a 3D text label to the scene. The label will be anchored at the specified 3D point." }, "add_action": { "open3d.visualization.O3DVisualizer": "Adds a button to the custom actions section of the UI and a corresponding menu item in the \u201cActions\u201d menu. add_action (name, callback). The callback will be given one parameter, the O3DVisualizer instance, and does not return any value." }, "add_geometry": { "open3d.visualization.O3DVisualizer": "Overloaded function.", "open3d.visualization.Visualizer": "Function to add geometry to the scene and create corresponding shaders", "open3d.visualization.VisualizerWithEditing": "Function to add geometry to the scene and create corresponding shaders", "open3d.visualization.VisualizerWithKeyCallback": "Function to add geometry to the scene and create corresponding shaders", "open3d.visualization.VisualizerWithVertexSelection": "Function to add geometry to the scene and create corresponding shaders", "open3d.visualization.rendering.Open3DScene": "Overloaded function.", "open3d.visualization.rendering.Scene": "Overloaded function." }, "clear_3d_labels": { "open3d.visualization.O3DVisualizer": "Clears all 3D text" }, "close_dialog": { "open3d.visualization.O3DVisualizer": "Closes the current dialog", "open3d.visualization.gui.Window": "Closes the current dialog" }, "enable_raw_mode": { "open3d.visualization.O3DVisualizer": "enable_raw_mode (enable): Enables/disables raw mode for simplified lighting environment." }, "export_current_image": { "open3d.visualization.O3DVisualizer": "export_image (path). Exports a PNG image of what is currently displayed to the given path." }, "get_geometry": { "open3d.visualization.O3DVisualizer": "get_geometry (name): Returns the DrawObject corresponding to the name. This should be treated as read-only. Modify visibility with show_geometry (), and other values by removing the object and re-adding it with the new values" }, "get_geometry_material": { "open3d.visualization.O3DVisualizer": "get_geometry_material (name): Returns the MaterialRecord corresponding to the name. The returned material is a copy, therefore modifying it directly will not change the visualization." }, "get_selection_sets": { "open3d.visualization.O3DVisualizer": "Returns the selection sets, as [{\u2018obj_name\u2019, [SelectedIndex]}]" }, "modify_geometry_material": { "open3d.visualization.O3DVisualizer": "modify_geometry_material (name,material): Updates the named geometry to use the new provided material.", "open3d.visualization.rendering.Open3DScene": "modify_geometry_material (name, material). Modifies the material of the specified geometry" }, "post_redraw": { "open3d.visualization.O3DVisualizer": "Tells the window to redraw", "open3d.visualization.gui.Window": "Sends a redraw message to the OS message queue" }, "remove_geometry": { "open3d.visualization.O3DVisualizer": "remove_geometry (name): removes the geometry with the name.", "open3d.visualization.Visualizer": "Function to remove geometry", "open3d.visualization.VisualizerWithEditing": "Function to remove geometry", "open3d.visualization.VisualizerWithKeyCallback": "Function to remove geometry", "open3d.visualization.VisualizerWithVertexSelection": "Function to remove geometry", "open3d.visualization.rendering.Open3DScene": "Removes the geometry with the given name" }, "reset_camera_to_default": { "open3d.visualization.O3DVisualizer": "Sets camera to default position" }, "set_background": { "open3d.visualization.O3DVisualizer": "set_background (color, image=None): Sets the background color and, optionally, the background image. Passing None for the background image will clear any image already there.", "open3d.visualization.rendering.Open3DScene": "set_background ([r, g, b, a], image=None). Sets the background color and (optionally) image of the scene." }, "set_ibl": { "open3d.visualization.O3DVisualizer": "set_ibl (ibl_name): Sets the IBL and its matching skybox. If ibl_name_ibl.ktx is found in the default resource directory then it is used. Otherwise, ibl_name is assumed to be a path to the ibl KTX file." }, "set_ibl_intensity": { "open3d.visualization.O3DVisualizer": "set_ibl_intensity (intensity): Sets the intensity of the current IBL" }, "set_on_animation_frame": { "open3d.visualization.O3DVisualizer": "set_on_animation (callback): Sets a callback that will be called every frame of the animation. The callback will be called as callback (o3dvis, current_time)." }, "set_on_animation_tick": { "open3d.visualization.O3DVisualizer": "set_on_animation (callback): Sets a callback that will be called every frame of the animation. The callback will be called as callback (o3dvis, time_since_last_tick, total_elapsed_since_animation_started). Note that this is a low-level callback. If you need to change the current timestamp being shown you will need to update the o3dvis.current_time property in the callback. The callback must return either O3DVisualizer.TickResult.IGNORE if no redraw is required or O3DVisualizer.TickResult.REDRAW if a redraw is required." }, "set_on_close": { "open3d.visualization.O3DVisualizer": "Sets a callback that will be called when the window is closed. The callback is given no arguments and should return True to continue closing the window or False to cancel the close", "open3d.visualization.gui.Window": "Sets a callback that will be called when the window is closed. The callback is given no arguments and should return True to continue closing the window or False to cancel the close" }, "show": { "open3d.visualization.O3DVisualizer": "Shows or hides the window", "open3d.visualization.gui.Window": "Shows or hides the window" }, "show_dialog": { "open3d.visualization.O3DVisualizer": "Displays the dialog", "open3d.visualization.gui.Window": "Displays the dialog" }, "show_geometry": { "open3d.visualization.O3DVisualizer": "Checks or unchecks the named geometry in the list. Note that even if show_geometry (name, True) is called, the object may not actually be visible if its group is unchecked, or if an animation is in progress.", "open3d.visualization.rendering.Open3DScene": "Shows or hides the geometry with the given name" }, "show_menu": { "open3d.visualization.O3DVisualizer": "show_menu (show): shows or hides the menu in the window, except on macOS since the menubar is not in the window and all applications must have a menubar.", "open3d.visualization.gui.Window": "show_menu (show): shows or hides the menu in the window, except on macOS since the menubar is not in the window and all applications must have a menubar." }, "show_message_box": { "open3d.visualization.O3DVisualizer": "Displays a simple dialog with a title and message and okay button", "open3d.visualization.gui.Window": "Displays a simple dialog with a title and message and okay button" }, "show_skybox": { "open3d.visualization.O3DVisualizer": "Show/Hide the skybox", "open3d.visualization.rendering.Open3DScene": "Toggles display of the skybox" }, "size_to_fit": { "open3d.visualization.O3DVisualizer": "Sets the width and height of window to its preferred size", "open3d.visualization.gui.Window": "Sets the width and height of window to its preferred size" }, "start_rpc_interface": { "open3d.visualization.O3DVisualizer": "Starts the RPC interface. address: str with the address to listen on. timeout: int timeout in milliseconds for sending the reply." }, "stop_rpc_interface": { "open3d.visualization.O3DVisualizer": "Stops the RPC interface." }, "update_geometry": { "open3d.visualization.O3DVisualizer": "update_geometry (name, tpoint_cloud, update_flags): updates the attributes of the named geometry specified by update_flags with tpoint_cloud. Note: Currently this function only works with T Geometry Point Clouds.", "open3d.visualization.Visualizer": "Function to update geometry. This function must be called when geometry has been changed. Otherwise the behavior of Visualizer is undefined.", "open3d.visualization.VisualizerWithEditing": "Function to update geometry. This function must be called when geometry has been changed. Otherwise the behavior of Visualizer is undefined.", "open3d.visualization.VisualizerWithKeyCallback": "Function to update geometry. This function must be called when geometry has been changed. Otherwise the behavior of Visualizer is undefined.", "open3d.visualization.VisualizerWithVertexSelection": "Function to update geometry. This function must be called when geometry has been changed. Otherwise the behavior of Visualizer is undefined.", "open3d.visualization.rendering.Scene": "Updates the flagged arrays from the tgeometry.PointCloud. The flags should be ORed from Scene.UPDATE_POINTS_FLAG, Scene.UPDATE_NORMALS_FLAG, Scene.UPDATE_COLORS_FLAG, and Scene.UPDATE_UV0_FLAG" }, "animation_duration": { "open3d.visualization.O3DVisualizer": "Gets/sets the duration (in seconds) of the animation. This is automatically computed to be the difference between the minimum and maximum time values, but this is useful if no time values have been specified (that is, all objects are at the default t=0)" }, "animation_frame_delay": { "open3d.visualization.O3DVisualizer": "Gets/sets the length of time a frame is visible." }, "animation_time_step": { "open3d.visualization.O3DVisualizer": "Gets/sets the time step for animations. Default is 1.0 sec" }, "content_rect": { "open3d.visualization.O3DVisualizer": "Returns the frame in device pixels, relative to the window, which is available for widgets (read-only)", "open3d.visualization.gui.Window": "Returns the frame in device pixels, relative to the window, which is available for widgets (read-only)" }, "current_time": { "open3d.visualization.O3DVisualizer": "Gets/sets the current time. If setting, only the objects belonging to the current time-step will be displayed" }, "ground_plane": { "open3d.visualization.O3DVisualizer": "Sets the plane for ground plane, XZ, XY, or YZ" }, "is_animating": { "open3d.visualization.O3DVisualizer": "Gets/sets the status of the animation. Changing value will start or stop the animating." }, "line_width": { "open3d.visualization.O3DVisualizer": "Gets/sets width of lines (in units of pixels)", "open3d.visualization.RenderOption": "Line width for LineSet.", "open3d.visualization.rendering.MaterialRecord": "Requires \u2018shader\u2019 to be \u2018unlitLine\u2019" }, "mouse_mode": { "open3d.visualization.O3DVisualizer": "Gets/sets the control mode being used for the mouse" }, "os_frame": { "open3d.visualization.O3DVisualizer": "Window rect in OS coords, not device pixels", "open3d.visualization.gui.Window": "Window rect in OS coords, not device pixels" }, "point_size": { "open3d.visualization.O3DVisualizer": "Gets/sets size of points (in units of pixels)", "open3d.visualization.RenderOption": "Point size for PointCloud." }, "scaling": { "open3d.visualization.O3DVisualizer": "Returns the scaling factor between OS pixels and device pixels (read-only)", "open3d.visualization.gui.UIImage": "Sets how the image is scaled: gui.UIImage.Scaling.NONE: no scaling gui.UIImage.Scaling.ANY: scaled to fit gui.UIImage.Scaling.ASPECT: scaled to fit but keeping the image\u2019s aspect ratio", "open3d.visualization.gui.Window": "Returns the scaling factor between OS pixels and device pixels (read-only)" }, "scene": { "open3d.visualization.O3DVisualizer": "Returns the rendering.Open3DScene object for low-level manipulation", "open3d.visualization.gui.SceneWidget": "The rendering.Open3DScene that the SceneWidget renders", "open3d.visualization.rendering.OffscreenRenderer": "Returns the Open3DScene for this renderer. This scene is destroyed when the renderer is destroyed and should not be accessed after that point.", "open3d.visualization.rendering.Open3DScene": "The low-level rendering scene object (read-only)" }, "scene_shader": { "open3d.visualization.O3DVisualizer": "Gets/sets the shading model for the scene" }, "show_axes": { "open3d.visualization.O3DVisualizer": "Gets/sets if axes are visible", "open3d.visualization.rendering.Open3DScene": "Toggles display of xyz axes" }, "show_ground": { "open3d.visualization.O3DVisualizer": "Gets/sets if ground plane is visible" }, "show_settings": { "open3d.visualization.O3DVisualizer": "Gets/sets if settings panel is visible" }, "title": { "open3d.visualization.O3DVisualizer": "Returns the title of the window", "open3d.visualization.gui.Window": "Returns the title of the window" }, "uid": { "open3d.visualization.O3DVisualizer": "Window\u2019s unique ID when WebRTCWindowSystem is use.Returns \u2018window_undefined\u2019 otherwise." }, "load_from_json": { "open3d.visualization.RenderOption": "Function to load RenderOption from a JSON file." }, "save_to_json": { "open3d.visualization.RenderOption": "Function to save RenderOption to a JSON file." }, "background_color": { "open3d.visualization.RenderOption": "Background RGB color.", "open3d.visualization.gui.Button": "Background color of the widget", "open3d.visualization.gui.CheckableTextTreeCell": "Background color of the widget", "open3d.visualization.gui.Checkbox": "Background color of the widget", "open3d.visualization.gui.CollapsableVert": "Background color of the widget", "open3d.visualization.gui.ColorEdit": "Background color of the widget", "open3d.visualization.gui.ColormapTreeCell": "Background color of the widget", "open3d.visualization.gui.Combobox": "Background color of the widget", "open3d.visualization.gui.Dialog": "Background color of the widget", "open3d.visualization.gui.FileDialog": "Background color of the widget", "open3d.visualization.gui.Horiz": "Background color of the widget", "open3d.visualization.gui.ImageWidget": "Background color of the widget", "open3d.visualization.gui.LUTTreeCell": "Background color of the widget", "open3d.visualization.gui.Label": "Background color of the widget", "open3d.visualization.gui.Layout1D": "Background color of the widget", "open3d.visualization.gui.ListView": "Background color of the widget", "open3d.visualization.gui.NumberEdit": "Background color of the widget", "open3d.visualization.gui.ProgressBar": "Background color of the widget", "open3d.visualization.gui.RadioButton": "Background color of the widget", "open3d.visualization.gui.SceneWidget": "Background color of the widget", "open3d.visualization.gui.ScrollableVert": "Background color of the widget", "open3d.visualization.gui.Slider": "Background color of the widget", "open3d.visualization.gui.StackedWidget": "Background color of the widget", "open3d.visualization.gui.TabControl": "Background color of the widget", "open3d.visualization.gui.TextEdit": "Background color of the widget", "open3d.visualization.gui.ToggleSwitch": "Background color of the widget", "open3d.visualization.gui.TreeView": "Background color of the widget", "open3d.visualization.gui.VGrid": "Background color of the widget", "open3d.visualization.gui.VectorEdit": "Background color of the widget", "open3d.visualization.gui.Vert": "Background color of the widget", "open3d.visualization.gui.Widget": "Background color of the widget", "open3d.visualization.gui.WidgetProxy": "Background color of the widget", "open3d.visualization.gui.WidgetStack": "Background color of the widget", "open3d.visualization.rendering.Open3DScene": "The background color (read-only)" }, "light_on": { "open3d.visualization.RenderOption": "Whether to turn on Phong lighting." }, "mesh_color_option": { "open3d.visualization.RenderOption": "Color option for TriangleMesh." }, "mesh_shade_option": { "open3d.visualization.RenderOption": "Mesh shading option for TriangleMesh." }, "mesh_show_back_face": { "open3d.visualization.RenderOption": "Whether to show back faces for TriangleMesh." }, "mesh_show_wireframe": { "open3d.visualization.RenderOption": "Whether to show wireframe for TriangleMesh." }, "point_color_option": { "open3d.visualization.RenderOption": "Point color option for PointCloud." }, "point_show_normal": { "open3d.visualization.RenderOption": "Whether to show normal for PointCloud." }, "show_coordinate_frame": { "open3d.visualization.RenderOption": "Whether to show coordinate frame." }, "order": { "open3d.visualization.SelectedIndex": "A monotonically increasing value that can be used to determine in what order the points were selected" }, "crop_in_polygon": { "open3d.visualization.SelectionPolygonVolume": "Function to crop 3d point clouds." }, "crop_point_cloud": { "open3d.visualization.SelectionPolygonVolume": "Function to crop point cloud." }, "crop_triangle_mesh": { "open3d.visualization.SelectionPolygonVolume": "Function to crop crop triangle mesh." }, "axis_max": { "open3d.visualization.SelectionPolygonVolume": "Maximum axis value." }, "axis_min": { "open3d.visualization.SelectionPolygonVolume": "Minimum axis value." }, "bounding_polygon": { "open3d.visualization.SelectionPolygonVolume": "Bounding polygon boundary." }, "orthogonal_axis": { "open3d.visualization.SelectionPolygonVolume": "one of {x, y, z}." }, "camera_local_rotate": { "open3d.visualization.ViewControl": "Function to process rotation of camera in a localcoordinate frame" }, "camera_local_translate": { "open3d.visualization.ViewControl": "Function to process translation of camera" }, "change_field_of_view": { "open3d.visualization.ViewControl": "Function to change field of view" }, "convert_from_pinhole_camera_parameters": { "open3d.visualization.ViewControl": "parameter (open3d.camera.PinholeCameraParameters) \u2013 The pinhole camera parameter to convert from." }, "convert_to_pinhole_camera_parameters": { "open3d.visualization.ViewControl": "Function to convert ViewControl to camera.PinholeCameraParameters" }, "get_field_of_view": { "open3d.visualization.ViewControl": "Function to get field of view", "open3d.visualization.rendering.Camera": "Returns the field of view of camera, in degrees. Only valid if it was passed to set_projection ()." }, "reset_camera_local_rotate": { "open3d.visualization.ViewControl": "Resets the coordinate frame for local camera rotations" }, "set_constant_z_far": { "open3d.visualization.ViewControl": "Function to change the far z-plane of the visualizer to a constant value, i.e., independent of zoom and bounding box size." }, "set_constant_z_near": { "open3d.visualization.ViewControl": "Function to change the near z-plane of the visualizer to a constant value, i.e., independent of zoom and bounding box size." }, "set_front": { "open3d.visualization.ViewControl": "Set the front vector of the visualizer" }, "set_lookat": { "open3d.visualization.ViewControl": "Set the lookat vector of the visualizer" }, "set_up": { "open3d.visualization.ViewControl": "Set the up vector of the visualizer" }, "set_zoom": { "open3d.visualization.ViewControl": "Set the zoom of the visualizer" }, "unset_constant_z_far": { "open3d.visualization.ViewControl": "Function to remove a previously set constant z far value, i.e., far z-plane of the visualizer is dynamically set dependent on zoom and bounding box size." }, "unset_constant_z_near": { "open3d.visualization.ViewControl": "Function to remove a previously set constant z near value, i.e., near z-plane of the visualizer is dynamically set dependent on zoom and bounding box size." }, "capture_depth_float_buffer": { "open3d.visualization.Visualizer": "Function to capture depth in a float buffer", "open3d.visualization.VisualizerWithEditing": "Function to capture depth in a float buffer", "open3d.visualization.VisualizerWithKeyCallback": "Function to capture depth in a float buffer", "open3d.visualization.VisualizerWithVertexSelection": "Function to capture depth in a float buffer" }, "capture_depth_image": { "open3d.visualization.Visualizer": "Function to capture and save a depth image", "open3d.visualization.VisualizerWithEditing": "Function to capture and save a depth image", "open3d.visualization.VisualizerWithKeyCallback": "Function to capture and save a depth image", "open3d.visualization.VisualizerWithVertexSelection": "Function to capture and save a depth image" }, "capture_depth_point_cloud": { "open3d.visualization.Visualizer": "Function to capture and save local point cloud", "open3d.visualization.VisualizerWithEditing": "Function to capture and save local point cloud", "open3d.visualization.VisualizerWithKeyCallback": "Function to capture and save local point cloud", "open3d.visualization.VisualizerWithVertexSelection": "Function to capture and save local point cloud" }, "capture_screen_float_buffer": { "open3d.visualization.Visualizer": "Function to capture screen and store RGB in a float buffer", "open3d.visualization.VisualizerWithEditing": "Function to capture screen and store RGB in a float buffer", "open3d.visualization.VisualizerWithKeyCallback": "Function to capture screen and store RGB in a float buffer", "open3d.visualization.VisualizerWithVertexSelection": "Function to capture screen and store RGB in a float buffer" }, "capture_screen_image": { "open3d.visualization.Visualizer": "Function to capture and save a screen image", "open3d.visualization.VisualizerWithEditing": "Function to capture and save a screen image", "open3d.visualization.VisualizerWithKeyCallback": "Function to capture and save a screen image", "open3d.visualization.VisualizerWithVertexSelection": "Function to capture and save a screen image" }, "clear_geometries": { "open3d.visualization.Visualizer": "Function to clear geometries from the visualizer", "open3d.visualization.VisualizerWithEditing": "Function to clear geometries from the visualizer", "open3d.visualization.VisualizerWithKeyCallback": "Function to clear geometries from the visualizer", "open3d.visualization.VisualizerWithVertexSelection": "Function to clear geometries from the visualizer" }, "create_window": { "open3d.visualization.Visualizer": "Function to create a window and initialize GLFW", "open3d.visualization.VisualizerWithEditing": "Function to create a window and initialize GLFW", "open3d.visualization.VisualizerWithKeyCallback": "Function to create a window and initialize GLFW", "open3d.visualization.VisualizerWithVertexSelection": "Function to create a window and initialize GLFW", "open3d.visualization.gui.Application": "Creates a window and adds it to the application. To programmatically destroy the window do window.close ().Usage: create_window (title, width, height, x, y, flags). x, y, and flags are optional." }, "destroy_window": { "open3d.visualization.Visualizer": "Function to destroy a window. This function MUST be called from the main thread.", "open3d.visualization.VisualizerWithEditing": "Function to destroy a window. This function MUST be called from the main thread.", "open3d.visualization.VisualizerWithKeyCallback": "Function to destroy a window. This function MUST be called from the main thread.", "open3d.visualization.VisualizerWithVertexSelection": "Function to destroy a window. This function MUST be called from the main thread." }, "get_render_option": { "open3d.visualization.Visualizer": "Function to retrieve the associated RenderOption", "open3d.visualization.VisualizerWithEditing": "Function to retrieve the associated RenderOption", "open3d.visualization.VisualizerWithKeyCallback": "Function to retrieve the associated RenderOption", "open3d.visualization.VisualizerWithVertexSelection": "Function to retrieve the associated RenderOption" }, "get_view_control": { "open3d.visualization.Visualizer": "Function to retrieve the associated ViewControl", "open3d.visualization.VisualizerWithEditing": "Function to retrieve the associated ViewControl", "open3d.visualization.VisualizerWithKeyCallback": "Function to retrieve the associated ViewControl", "open3d.visualization.VisualizerWithVertexSelection": "Function to retrieve the associated ViewControl" }, "get_window_name": { "open3d.visualization.Visualizer": "str", "open3d.visualization.VisualizerWithEditing": "str", "open3d.visualization.VisualizerWithKeyCallback": "str", "open3d.visualization.VisualizerWithVertexSelection": "str" }, "is_full_screen": { "open3d.visualization.Visualizer": "Function to query whether in fullscreen mode", "open3d.visualization.VisualizerWithEditing": "Function to query whether in fullscreen mode", "open3d.visualization.VisualizerWithKeyCallback": "Function to query whether in fullscreen mode", "open3d.visualization.VisualizerWithVertexSelection": "Function to query whether in fullscreen mode" }, "poll_events": { "open3d.visualization.Visualizer": "Function to poll events", "open3d.visualization.VisualizerWithEditing": "Function to poll events", "open3d.visualization.VisualizerWithKeyCallback": "Function to poll events", "open3d.visualization.VisualizerWithVertexSelection": "Function to poll events" }, "register_animation_callback": { "open3d.visualization.Visualizer": "Function to register a callback function for animation. The callback function returns if UpdateGeometry () needs to be run.", "open3d.visualization.VisualizerWithEditing": "Function to register a callback function for animation. The callback function returns if UpdateGeometry () needs to be run.", "open3d.visualization.VisualizerWithKeyCallback": "Function to register a callback function for animation. The callback function returns if UpdateGeometry () needs to be run.", "open3d.visualization.VisualizerWithVertexSelection": "Function to register a callback function for animation. The callback function returns if UpdateGeometry () needs to be run." }, "reset_view_point": { "open3d.visualization.Visualizer": "Function to reset view point", "open3d.visualization.VisualizerWithEditing": "Function to reset view point", "open3d.visualization.VisualizerWithKeyCallback": "Function to reset view point", "open3d.visualization.VisualizerWithVertexSelection": "Function to reset view point" }, "run": { "open3d.visualization.Visualizer": "Function to activate the window. This function will block the current thread until the window is closed.", "open3d.visualization.VisualizerWithEditing": "Function to activate the window. This function will block the current thread until the window is closed.", "open3d.visualization.VisualizerWithKeyCallback": "Function to activate the window. This function will block the current thread until the window is closed.", "open3d.visualization.VisualizerWithVertexSelection": "Function to activate the window. This function will block the current thread until the window is closed.", "open3d.visualization.gui.Application": "Runs the event loop. After this finishes, all windows and widgets should be considered uninitialized, even if they are still held by Python variables. Using them is unsafe, even if run () is called again." }, "set_full_screen": { "open3d.visualization.Visualizer": "Function to change between fullscreen and windowed", "open3d.visualization.VisualizerWithEditing": "Function to change between fullscreen and windowed", "open3d.visualization.VisualizerWithKeyCallback": "Function to change between fullscreen and windowed", "open3d.visualization.VisualizerWithVertexSelection": "Function to change between fullscreen and windowed" }, "toggle_full_screen": { "open3d.visualization.Visualizer": "Function to toggle between fullscreen and windowed", "open3d.visualization.VisualizerWithEditing": "Function to toggle between fullscreen and windowed", "open3d.visualization.VisualizerWithKeyCallback": "Function to toggle between fullscreen and windowed", "open3d.visualization.VisualizerWithVertexSelection": "Function to toggle between fullscreen and windowed" }, "update_renderer": { "open3d.visualization.Visualizer": "Function to inform render needed to be updated", "open3d.visualization.VisualizerWithEditing": "Function to inform render needed to be updated", "open3d.visualization.VisualizerWithKeyCallback": "Function to inform render needed to be updated", "open3d.visualization.VisualizerWithVertexSelection": "Function to inform render needed to be updated" }, "get_cropped_geometry": { "open3d.visualization.VisualizerWithEditing": "Function to get cropped geometry" }, "get_picked_points": { "open3d.visualization.VisualizerWithEditing": "Function to get picked points", "open3d.visualization.VisualizerWithVertexSelection": "Function to get picked points" }, "register_key_action_callback": { "open3d.visualization.VisualizerWithKeyCallback": "Function to register a callback function for a key action event. The callback function takes Visualizer, action and mods as input and returns a boolean indicating if UpdateGeometry () needs to be run." }, "register_key_callback": { "open3d.visualization.VisualizerWithKeyCallback": "Function to register a callback function for a key press event" }, "add_picked_points": { "open3d.visualization.VisualizerWithVertexSelection": "Function to add picked points" }, "clear_picked_points": { "open3d.visualization.VisualizerWithVertexSelection": "Function to clear picked points" }, "pick_points": { "open3d.visualization.VisualizerWithVertexSelection": "Function to pick points" }, "register_selection_changed_callback": { "open3d.visualization.VisualizerWithVertexSelection": "Registers a function to be called when selection changes" }, "register_selection_moved_callback": { "open3d.visualization.VisualizerWithVertexSelection": "Registers a function to be called after selection moves" }, "register_selection_moving_callback": { "open3d.visualization.VisualizerWithVertexSelection": "Registers a function to be called while selection moves. Geometry\u2019s vertex values can be changed, but do not changethe number of vertices." }, "remove_picked_points": { "open3d.visualization.VisualizerWithVertexSelection": "Function to remove picked points" }, "add_font": { "open3d.visualization.gui.Application": "Adds a font. Must be called after initialize () and before a window is created. Returns the font id, which can be used to change the font in widgets such as Label which support custom fonts." }, "add_window": { "open3d.visualization.gui.Application": "Adds a window to the application. This is only necessary when creating an object that is a Window directly, rather than with create_window" }, "initialize": { "open3d.visualization.gui.Application": "Overloaded function." }, "post_to_main_thread": { "open3d.visualization.gui.Application": "Runs the provided function on the main thread. This can be used to execute UI-related code at a safe point in time. If the UI changes, you will need to manually request a redraw of the window with w.post_redraw ()" }, "quit": { "open3d.visualization.gui.Application": "Closes all the windows, exiting as a result" }, "render_to_image": { "open3d.visualization.gui.Application": "Renders a scene to an image and returns the image. If you are rendering without a visible window you should use open3d.visualization.rendering.RenderToImage instead", "open3d.visualization.rendering.OffscreenRenderer": "Renders scene to an image, blocking until the image is returned", "open3d.visualization.rendering.Scene": "Renders the scene to an image. This can only be used in a GUI app. To render without a window, use Application.render_to_image" }, "run_in_thread": { "open3d.visualization.gui.Application": "Runs function in a separate thread. Do not call GUI functions on this thread, call post_to_main_thread () if this thread needs to change the GUI." }, "run_one_tick": { "open3d.visualization.gui.Application": "Runs the event loop once, returns True if the app is still running, or False if all the windows have closed or quit () has been called." }, "set_font": { "open3d.visualization.gui.Application": "Changes the contents of an existing font, for instance, the default font." }, "menubar": { "open3d.visualization.gui.Application": "The Menu for the application (initially None)" }, "now": { "open3d.visualization.gui.Application": "Returns current time in seconds" }, "resource_path": { "open3d.visualization.gui.Application": "Returns a string with the path to the resources directory" }, "add_child": { "open3d.visualization.gui.Button": "Adds a child widget", "open3d.visualization.gui.CheckableTextTreeCell": "Adds a child widget", "open3d.visualization.gui.Checkbox": "Adds a child widget", "open3d.visualization.gui.CollapsableVert": "Adds a child widget", "open3d.visualization.gui.ColorEdit": "Adds a child widget", "open3d.visualization.gui.ColormapTreeCell": "Adds a child widget", "open3d.visualization.gui.Combobox": "Adds a child widget", "open3d.visualization.gui.Dialog": "Adds a child widget", "open3d.visualization.gui.FileDialog": "Adds a child widget", "open3d.visualization.gui.Horiz": "Adds a child widget", "open3d.visualization.gui.ImageWidget": "Adds a child widget", "open3d.visualization.gui.LUTTreeCell": "Adds a child widget", "open3d.visualization.gui.Label": "Adds a child widget", "open3d.visualization.gui.Layout1D": "Adds a child widget", "open3d.visualization.gui.ListView": "Adds a child widget", "open3d.visualization.gui.NumberEdit": "Adds a child widget", "open3d.visualization.gui.ProgressBar": "Adds a child widget", "open3d.visualization.gui.RadioButton": "Adds a child widget", "open3d.visualization.gui.SceneWidget": "Adds a child widget", "open3d.visualization.gui.ScrollableVert": "Adds a child widget", "open3d.visualization.gui.Slider": "Adds a child widget", "open3d.visualization.gui.StackedWidget": "Adds a child widget", "open3d.visualization.gui.TabControl": "Adds a child widget", "open3d.visualization.gui.TextEdit": "Adds a child widget", "open3d.visualization.gui.ToggleSwitch": "Adds a child widget", "open3d.visualization.gui.TreeView": "Adds a child widget", "open3d.visualization.gui.VGrid": "Adds a child widget", "open3d.visualization.gui.VectorEdit": "Adds a child widget", "open3d.visualization.gui.Vert": "Adds a child widget", "open3d.visualization.gui.Widget": "Adds a child widget", "open3d.visualization.gui.WidgetProxy": "Adds a child widget", "open3d.visualization.gui.WidgetStack": "Adds a child widget", "open3d.visualization.gui.Window": "Adds a widget to the window" }, "calc_preferred_size": { "open3d.visualization.gui.Button": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.CheckableTextTreeCell": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Checkbox": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.CollapsableVert": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ColorEdit": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ColormapTreeCell": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Combobox": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Dialog": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.FileDialog": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Horiz": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ImageWidget": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.LUTTreeCell": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Label": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Layout1D": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ListView": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.NumberEdit": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ProgressBar": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.RadioButton": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.SceneWidget": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ScrollableVert": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Slider": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.StackedWidget": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.TabControl": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.TextEdit": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.ToggleSwitch": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.TreeView": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.VGrid": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.VectorEdit": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Vert": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.Widget": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.WidgetProxy": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly", "open3d.visualization.gui.WidgetStack": "Returns the preferred size of the widget. This is intended to be called only during layout, although it will also work during drawing. Calling it at other times will not work, as it requires some internal setup in order to function properly" }, "get_children": { "open3d.visualization.gui.Button": "Returns the array of children. Do not modify.", "open3d.visualization.gui.CheckableTextTreeCell": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Checkbox": "Returns the array of children. Do not modify.", "open3d.visualization.gui.CollapsableVert": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ColorEdit": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ColormapTreeCell": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Combobox": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Dialog": "Returns the array of children. Do not modify.", "open3d.visualization.gui.FileDialog": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Horiz": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ImageWidget": "Returns the array of children. Do not modify.", "open3d.visualization.gui.LUTTreeCell": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Label": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Layout1D": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ListView": "Returns the array of children. Do not modify.", "open3d.visualization.gui.NumberEdit": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ProgressBar": "Returns the array of children. Do not modify.", "open3d.visualization.gui.RadioButton": "Returns the array of children. Do not modify.", "open3d.visualization.gui.SceneWidget": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ScrollableVert": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Slider": "Returns the array of children. Do not modify.", "open3d.visualization.gui.StackedWidget": "Returns the array of children. Do not modify.", "open3d.visualization.gui.TabControl": "Returns the array of children. Do not modify.", "open3d.visualization.gui.TextEdit": "Returns the array of children. Do not modify.", "open3d.visualization.gui.ToggleSwitch": "Returns the array of children. Do not modify.", "open3d.visualization.gui.TreeView": "Returns the array of children. Do not modify.", "open3d.visualization.gui.VGrid": "Returns the array of children. Do not modify.", "open3d.visualization.gui.VectorEdit": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Vert": "Returns the array of children. Do not modify.", "open3d.visualization.gui.Widget": "Returns the array of children. Do not modify.", "open3d.visualization.gui.WidgetProxy": "Returns the array of children. Do not modify.", "open3d.visualization.gui.WidgetStack": "Returns the array of children. Do not modify." }, "set_on_clicked": { "open3d.visualization.gui.Button": "Calls passed function when button is pressed", "open3d.visualization.gui.ToggleSwitch": "Sets f (is_on) which is called when the switch changes state." }, "enabled": { "open3d.visualization.gui.Button": "True if widget is enabled, False if disabled", "open3d.visualization.gui.CheckableTextTreeCell": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Checkbox": "True if widget is enabled, False if disabled", "open3d.visualization.gui.CollapsableVert": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ColorEdit": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ColormapTreeCell": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Combobox": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Dialog": "True if widget is enabled, False if disabled", "open3d.visualization.gui.FileDialog": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Horiz": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ImageWidget": "True if widget is enabled, False if disabled", "open3d.visualization.gui.LUTTreeCell": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Label": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Layout1D": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ListView": "True if widget is enabled, False if disabled", "open3d.visualization.gui.NumberEdit": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ProgressBar": "True if widget is enabled, False if disabled", "open3d.visualization.gui.RadioButton": "True if widget is enabled, False if disabled", "open3d.visualization.gui.SceneWidget": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ScrollableVert": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Slider": "True if widget is enabled, False if disabled", "open3d.visualization.gui.StackedWidget": "True if widget is enabled, False if disabled", "open3d.visualization.gui.TabControl": "True if widget is enabled, False if disabled", "open3d.visualization.gui.TextEdit": "True if widget is enabled, False if disabled", "open3d.visualization.gui.ToggleSwitch": "True if widget is enabled, False if disabled", "open3d.visualization.gui.TreeView": "True if widget is enabled, False if disabled", "open3d.visualization.gui.VGrid": "True if widget is enabled, False if disabled", "open3d.visualization.gui.VectorEdit": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Vert": "True if widget is enabled, False if disabled", "open3d.visualization.gui.Widget": "True if widget is enabled, False if disabled", "open3d.visualization.gui.WidgetProxy": "True if widget is enabled, False if disabled", "open3d.visualization.gui.WidgetStack": "True if widget is enabled, False if disabled" }, "frame": { "open3d.visualization.gui.Button": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.CheckableTextTreeCell": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Checkbox": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.CollapsableVert": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ColorEdit": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ColormapTreeCell": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Combobox": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Dialog": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.FileDialog": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Horiz": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ImageWidget": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.LUTTreeCell": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Label": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Layout1D": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ListView": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.NumberEdit": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ProgressBar": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.RadioButton": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.SceneWidget": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ScrollableVert": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Slider": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.StackedWidget": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.TabControl": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.TextEdit": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.ToggleSwitch": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.TreeView": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.VGrid": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.VectorEdit": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Vert": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.Widget": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.WidgetProxy": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout.", "open3d.visualization.gui.WidgetStack": "The widget\u2019s frame. Setting this value will be overridden if the frame is within a layout." }, "horizontal_padding_em": { "open3d.visualization.gui.Button": "Horizontal padding in em units" }, "is_on": { "open3d.visualization.gui.Button": "True if the button is toggleable and in the on state", "open3d.visualization.gui.ToggleSwitch": "True if is one, False otherwise" }, "text": { "open3d.visualization.gui.Button": "Gets/sets the button text.", "open3d.visualization.gui.Label": "The text of the label. Newlines will be treated as line breaks", "open3d.visualization.gui.Label3D": "The text to display with this label." }, "toggleable": { "open3d.visualization.gui.Button": "True if button is toggleable, False if a push button" }, "tooltip": { "open3d.visualization.gui.Button": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.CheckableTextTreeCell": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Checkbox": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.CollapsableVert": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ColorEdit": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ColormapTreeCell": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Combobox": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Dialog": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.FileDialog": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Horiz": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ImageWidget": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.LUTTreeCell": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Label": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Layout1D": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ListView": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.NumberEdit": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ProgressBar": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.RadioButton": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.SceneWidget": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ScrollableVert": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Slider": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.StackedWidget": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.TabControl": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.TextEdit": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.ToggleSwitch": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.TreeView": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.VGrid": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.VectorEdit": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Vert": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.Widget": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.WidgetProxy": "Widget\u2019s tooltip that is displayed on mouseover", "open3d.visualization.gui.WidgetStack": "Widget\u2019s tooltip that is displayed on mouseover" }, "vertical_padding_em": { "open3d.visualization.gui.Button": "Vertical padding in em units" }, "visible": { "open3d.visualization.gui.Button": "True if widget is visible, False otherwise", "open3d.visualization.gui.CheckableTextTreeCell": "True if widget is visible, False otherwise", "open3d.visualization.gui.Checkbox": "True if widget is visible, False otherwise", "open3d.visualization.gui.CollapsableVert": "True if widget is visible, False otherwise", "open3d.visualization.gui.ColorEdit": "True if widget is visible, False otherwise", "open3d.visualization.gui.ColormapTreeCell": "True if widget is visible, False otherwise", "open3d.visualization.gui.Combobox": "True if widget is visible, False otherwise", "open3d.visualization.gui.Dialog": "True if widget is visible, False otherwise", "open3d.visualization.gui.FileDialog": "True if widget is visible, False otherwise", "open3d.visualization.gui.Horiz": "True if widget is visible, False otherwise", "open3d.visualization.gui.ImageWidget": "True if widget is visible, False otherwise", "open3d.visualization.gui.LUTTreeCell": "True if widget is visible, False otherwise", "open3d.visualization.gui.Label": "True if widget is visible, False otherwise", "open3d.visualization.gui.Layout1D": "True if widget is visible, False otherwise", "open3d.visualization.gui.ListView": "True if widget is visible, False otherwise", "open3d.visualization.gui.NumberEdit": "True if widget is visible, False otherwise", "open3d.visualization.gui.ProgressBar": "True if widget is visible, False otherwise", "open3d.visualization.gui.RadioButton": "True if widget is visible, False otherwise", "open3d.visualization.gui.SceneWidget": "True if widget is visible, False otherwise", "open3d.visualization.gui.ScrollableVert": "True if widget is visible, False otherwise", "open3d.visualization.gui.Slider": "True if widget is visible, False otherwise", "open3d.visualization.gui.StackedWidget": "True if widget is visible, False otherwise", "open3d.visualization.gui.TabControl": "True if widget is visible, False otherwise", "open3d.visualization.gui.TextEdit": "True if widget is visible, False otherwise", "open3d.visualization.gui.ToggleSwitch": "True if widget is visible, False otherwise", "open3d.visualization.gui.TreeView": "True if widget is visible, False otherwise", "open3d.visualization.gui.VGrid": "True if widget is visible, False otherwise", "open3d.visualization.gui.VectorEdit": "True if widget is visible, False otherwise", "open3d.visualization.gui.Vert": "True if widget is visible, False otherwise", "open3d.visualization.gui.Widget": "True if widget is visible, False otherwise", "open3d.visualization.gui.WidgetProxy": "True if widget is visible, False otherwise", "open3d.visualization.gui.WidgetStack": "True if widget is visible, False otherwise" }, "checkbox": { "open3d.visualization.gui.CheckableTextTreeCell": "Returns the checkbox widget (property is read-only)", "open3d.visualization.gui.LUTTreeCell": "Returns the checkbox widget (property is read-only)" }, "label": { "open3d.visualization.gui.CheckableTextTreeCell": "Returns the label widget (property is read-only)", "open3d.visualization.gui.LUTTreeCell": "Returns the label widget (property is read-only)" }, "set_on_checked": { "open3d.visualization.gui.Checkbox": "Calls passed function when checkbox changes state" }, "checked": { "open3d.visualization.gui.Checkbox": "True if checked, False otherwise" }, "add_fixed": { "open3d.visualization.gui.CollapsableVert": "Overloaded function.", "open3d.visualization.gui.Horiz": "Overloaded function.", "open3d.visualization.gui.Layout1D": "Overloaded function.", "open3d.visualization.gui.ScrollableVert": "Overloaded function.", "open3d.visualization.gui.Vert": "Overloaded function." }, "add_stretch": { "open3d.visualization.gui.CollapsableVert": "Adds empty space to the layout that will take up as much extra space as there is available in the layout", "open3d.visualization.gui.Horiz": "Adds empty space to the layout that will take up as much extra space as there is available in the layout", "open3d.visualization.gui.Layout1D": "Adds empty space to the layout that will take up as much extra space as there is available in the layout", "open3d.visualization.gui.ScrollableVert": "Adds empty space to the layout that will take up as much extra space as there is available in the layout", "open3d.visualization.gui.Vert": "Adds empty space to the layout that will take up as much extra space as there is available in the layout" }, "get_is_open": { "open3d.visualization.gui.CollapsableVert": "Check if widget is open." }, "set_is_open": { "open3d.visualization.gui.CollapsableVert": "Sets to collapsed (False) or open (True). Requires a call to Window.SetNeedsLayout () afterwards, unless calling before window is visible" }, "font_id": { "open3d.visualization.gui.CollapsableVert": "Set the font using the FontId returned from Application.add_font ()", "open3d.visualization.gui.Label": "Set the font using the FontId returned from Application.add_font ()" }, "preferred_width": { "open3d.visualization.gui.CollapsableVert": "Sets the preferred width of the layout", "open3d.visualization.gui.ScrollableVert": "Sets the preferred width of the layout", "open3d.visualization.gui.VGrid": "Sets the preferred width of the layout", "open3d.visualization.gui.Vert": "Sets the preferred width of the layout" }, "alpha": { "open3d.visualization.gui.Color": "Returns alpha channel in the range [0.0, 1.0] (read-only)" }, "blue": { "open3d.visualization.gui.Color": "Returns blue channel in the range [0.0, 1.0] (read-only)" }, "green": { "open3d.visualization.gui.Color": "Returns green channel in the range [0.0, 1.0] (read-only)" }, "red": { "open3d.visualization.gui.Color": "Returns red channel in the range [0.0, 1.0] (read-only)" }, "set_on_value_changed": { "open3d.visualization.gui.ColorEdit": "Calls f (Color) when color changes by user input", "open3d.visualization.gui.NumberEdit": "Sets f (new_value) which is called with a Float when user changes widget\u2019s value", "open3d.visualization.gui.Slider": "Sets f (new_value) which is called with a Float when user changes widget\u2019s value", "open3d.visualization.gui.TextEdit": "Sets f (new_text) which is called with the new text when the user completes text editing", "open3d.visualization.gui.VectorEdit": "Sets f ([x, y, z]) which is called whenever the user changes the value of a component" }, "color_value": { "open3d.visualization.gui.ColorEdit": "Color value (gui.Color)" }, "color_edit": { "open3d.visualization.gui.ColormapTreeCell": "Returns the ColorEdit widget (property is read-only)", "open3d.visualization.gui.LUTTreeCell": "Returns the ColorEdit widget (property is read-only)" }, "number_edit": { "open3d.visualization.gui.ColormapTreeCell": "Returns the NumberEdit widget (property is read-only)" }, "add_item": { "open3d.visualization.gui.Combobox": "Adds an item to the end", "open3d.visualization.gui.Menu": "Adds a menu item with id to the menu", "open3d.visualization.gui.TreeView": "Adds a child item to the parent. add_item (parent, widget)" }, "change_item": { "open3d.visualization.gui.Combobox": "Overloaded function." }, "clear_items": { "open3d.visualization.gui.Combobox": "Removes all items" }, "get_item": { "open3d.visualization.gui.Combobox": "Returns the item at the given index" }, "remove_item": { "open3d.visualization.gui.Combobox": "Overloaded function.", "open3d.visualization.gui.TreeView": "Removes an item and all its children (if any)" }, "set_on_selection_changed": { "open3d.visualization.gui.Combobox": "Calls f (str, int) when user selects item from combobox. Arguments are the selected text and selected index, respectively", "open3d.visualization.gui.ListView": "Calls f (new_val, is_double_click) when user changes selection", "open3d.visualization.gui.RadioButton": "Calls f (new_idx) when user changes selection", "open3d.visualization.gui.TreeView": "Sets f (new_item_id) which is called when the user changes the selection." }, "number_of_items": { "open3d.visualization.gui.Combobox": "The number of items (read-only)" }, "selected_index": { "open3d.visualization.gui.Combobox": "The index of the currently selected item", "open3d.visualization.gui.ListView": "The index of the currently selected item", "open3d.visualization.gui.RadioButton": "The index of the currently selected item", "open3d.visualization.gui.StackedWidget": "Selects the index of the child to display" }, "selected_text": { "open3d.visualization.gui.Combobox": "The index of the currently selected item" }, "add_filter": { "open3d.visualization.gui.FileDialog": "Adds a selectable file-type filter: add_filter (\u2018.stl\u2019, \u2018Stereolithography mesh\u2019" }, "set_on_cancel": { "open3d.visualization.gui.FileDialog": "Cancel callback; required" }, "set_on_done": { "open3d.visualization.gui.FileDialog": "Done callback; required" }, "set_path": { "open3d.visualization.gui.FileDialog": "Sets the initial path path of the dialog" }, "add_typeface_for_code_points": { "open3d.visualization.gui.FontDescription": "Adds specific code points from the typeface. This is useful for selectively adding glyphs, for example, from an icon font." }, "add_typeface_for_language": { "open3d.visualization.gui.FontDescription": "\u2018ja\u2019 (Japanese) \u2018ko\u2019 (Korean) \u2018th\u2019 (Thai) \u2018vi\u2019 (Vietnamese) \u2018zh\u2019 (Chinese, 2500 most common characters, 50 MB per window) \u2018zh_all\u2019 (Chinese, all characters, ~200 MB per window)" }, "preferred_height": { "open3d.visualization.gui.Horiz": "Sets the preferred height of the layout" }, "update_image": { "open3d.visualization.gui.ImageWidget": "Overloaded function." }, "ui_image": { "open3d.visualization.gui.ImageWidget": "Replaces the texture with a new texture. This is not a fast path, and is not recommended for video as you will exhaust internal texture resources." }, "is_repeat": { "open3d.visualization.gui.KeyEvent": "True if this key down event comes from a key repeat" }, "key": { "open3d.visualization.gui.KeyEvent": "This is the actual key that was pressed, not the character generated by the key. This event is not suitable for text entry" }, "type": { "open3d.visualization.gui.KeyEvent": "Key event type", "open3d.visualization.gui.MouseEvent": "Mouse event type" }, "text_color": { "open3d.visualization.gui.Label": "The color of the text (gui.Color)" }, "position": { "open3d.visualization.gui.Label3D": "The position of the text in 3D coordinates" }, "set_items": { "open3d.visualization.gui.ListView": "Sets the list to display the list of items provided", "open3d.visualization.gui.RadioButton": "Set radio items, each item is a radio button." }, "set_max_visible_items": { "open3d.visualization.gui.ListView": "Limit the max visible items shown to user. Set to negative number will make list extends vertically as much as possible, otherwise the list will at least show 3 items and at most show num items." }, "selected_value": { "open3d.visualization.gui.ListView": "The text of the currently selected item", "open3d.visualization.gui.RadioButton": "The text of the currently selected item" }, "add_menu": { "open3d.visualization.gui.Menu": "Adds a submenu to the menu" }, "add_separator": { "open3d.visualization.gui.Menu": "Adds a separator to the menu" }, "is_checked": { "open3d.visualization.gui.Menu": "Returns True if menu item is checked" }, "set_checked": { "open3d.visualization.gui.Menu": "Sets menu item (un)checked" }, "set_enabled": { "open3d.visualization.gui.Menu": "Sets menu item enabled or disabled" }, "is_button_down": { "open3d.visualization.gui.MouseEvent": "Convenience function to more easily deterimine if a mouse button is pressed" }, "is_modifier_down": { "open3d.visualization.gui.MouseEvent": "Convenience function to more easily deterimine if a modifier key is down" }, "buttons": { "open3d.visualization.gui.MouseEvent": "ORed mouse buttons" }, "modifiers": { "open3d.visualization.gui.MouseEvent": "ORed mouse modifiers" }, "wheel_dx": { "open3d.visualization.gui.MouseEvent": "Mouse wheel horizontal motion" }, "wheel_dy": { "open3d.visualization.gui.MouseEvent": "Mouse wheel vertical motion" }, "wheel_is_trackpad": { "open3d.visualization.gui.MouseEvent": "Is mouse wheel event from a trackpad" }, "x": { "open3d.visualization.gui.MouseEvent": "x coordinate of the mouse event" }, "y": { "open3d.visualization.gui.MouseEvent": "y coordinate of the mouse event" }, "set_limits": { "open3d.visualization.gui.NumberEdit": "Sets the minimum and maximum values for the number", "open3d.visualization.gui.Slider": "Sets the minimum and maximum values for the slider" }, "set_preferred_width": { "open3d.visualization.gui.NumberEdit": "Overloaded function." }, "set_value": { "open3d.visualization.gui.NumberEdit": "Sets value" }, "decimal_precision": { "open3d.visualization.gui.NumberEdit": "Number of fractional digits shown" }, "double_value": { "open3d.visualization.gui.NumberEdit": "Current value (double)", "open3d.visualization.gui.Slider": "Slider value (double)" }, "int_value": { "open3d.visualization.gui.NumberEdit": "Current value (int)", "open3d.visualization.gui.Slider": "Slider value (int)" }, "maximum_value": { "open3d.visualization.gui.NumberEdit": "The maximum value number can contain (read-only, use set_limits () to set)" }, "minimum_value": { "open3d.visualization.gui.NumberEdit": "The minimum value number can contain (read-only, use set_limits () to set)" }, "value": { "open3d.visualization.gui.ProgressBar": "The value of the progress bar, ranges from 0.0 to 1.0", "open3d.visualization.rendering.Gradient.Point": "Must be within 0.0 and 1.0" }, "enable_scene_caching": { "open3d.visualization.gui.SceneWidget": "Enable/Disable caching of scene content when the view or model is not changing. Scene caching can help improve UI responsiveness for large models and point clouds" }, "force_redraw": { "open3d.visualization.gui.SceneWidget": "Ensures scene redraws even when scene caching is enabled." }, "look_at": { "open3d.visualization.gui.SceneWidget": "look_at (center, eye, up): sets the camera view so that the camera is located at \u2018eye\u2019, pointing towards \u2018center\u2019, and oriented so that the up vector is \u2018up\u2019", "open3d.visualization.rendering.Camera": "Sets the position and orientation of the camera: look_at (center, eye, up)" }, "remove_3d_label": { "open3d.visualization.gui.SceneWidget": "Removes the 3D text label from the scene" }, "set_on_key": { "open3d.visualization.gui.SceneWidget": "Sets a callback for key events. This callback is passed a KeyEvent object. The callback must return EventCallbackResult.IGNORED, EventCallbackResult.HANDLED, or EventCallbackResult.CONSUMED.", "open3d.visualization.gui.Window": "Sets a callback for key events. This callback is passed a KeyEvent object. The callback must return True to stop more dispatching or False to dispatchto focused widget" }, "set_on_mouse": { "open3d.visualization.gui.SceneWidget": "Sets a callback for mouse events. This callback is passed a MouseEvent object. The callback must return EventCallbackResult.IGNORED, EventCallbackResult.HANDLED, or EventCallbackResult.CONSUMED." }, "set_on_sun_direction_changed": { "open3d.visualization.gui.SceneWidget": "Callback when user changes sun direction (only called in ROTATE_SUN control mode). Called with one argument, the [i, j, k] vector of the new sun direction" }, "set_view_controls": { "open3d.visualization.gui.SceneWidget": "Sets mouse interaction, e.g. ROTATE_OBJ" }, "center_of_rotation": { "open3d.visualization.gui.SceneWidget": "Current center of rotation (for ROTATE_CAMERA and ROTATE_CAMERA_SPHERE)" }, "get_maximum_value": { "open3d.visualization.gui.Slider": "The maximum value number can contain (read-only, use set_limits () to set)" }, "get_minimum_value": { "open3d.visualization.gui.Slider": "The minimum value number can contain (read-only, use set_limits () to set)" }, "add_tab": { "open3d.visualization.gui.TabControl": "Adds a tab. The first parameter is the title of the tab, and the second parameter is a widget\u2013normally this is a layout." }, "set_on_selected_tab_changed": { "open3d.visualization.gui.TabControl": "Calls the provided callback function with the index of the currently selected tab whenever the user clicks on a different tab" }, "selected_tab_index": { "open3d.visualization.gui.TabControl": "The index of the currently selected item" }, "set_on_text_changed": { "open3d.visualization.gui.TextEdit": "Sets f (new_text) which is called whenever the the user makes a change to the text" }, "placeholder_text": { "open3d.visualization.gui.TextEdit": "The placeholder text displayed when text value is empty" }, "text_value": { "open3d.visualization.gui.TextEdit": "The value of text" }, "default_layout_spacing": { "open3d.visualization.gui.Theme": "Good value for the spacing parameter in layouts (read-only)" }, "default_margin": { "open3d.visualization.gui.Theme": "Good default value for margins, useful for layouts (read-only)" }, "font_size": { "open3d.visualization.gui.Theme": "Font size (which is also the conventional size of the em unit) (read-only)" }, "add_text_item": { "open3d.visualization.gui.TreeView": "Adds a child item to the parent. add_text_item (parent, text)" }, "get_root_item": { "open3d.visualization.gui.TreeView": "Returns the root item. This item is invisible, so its child are the top-level items" }, "can_select_items_with_children": { "open3d.visualization.gui.TreeView": "If set to False, clicking anywhere on an item with will toggle the item open or closed; the item cannot be selected. If set to True, items with children can be selected, and to toggle open/closed requires clicking the arrow or double-clicking the item" }, "selected_item": { "open3d.visualization.gui.TreeView": "The currently selected item" }, "margins": { "open3d.visualization.gui.VGrid": "Returns the margins" }, "spacing": { "open3d.visualization.gui.VGrid": "Returns the spacing between rows and columns" }, "vector_value": { "open3d.visualization.gui.VectorEdit": "Returns value [x, y, z]" }, "get_widget": { "open3d.visualization.gui.WidgetProxy": "Retrieve current delegated widget.return instance of current delegated widget set by set_widget. An empty pointer will be returned if there is none.", "open3d.visualization.gui.WidgetStack": "Retrieve current delegated widget.return instance of current delegated widget set by set_widget. An empty pointer will be returned if there is none." }, "set_widget": { "open3d.visualization.gui.WidgetProxy": "set a new widget to be delegated by this one. After set_widget, the previously delegated widget , will be abandon all calls to Widget\u2019s API will be conducted to widget. Before any set_widget call, this widget is invisible and disabled, seems it does not exist because it won\u2019t be drawn or in a layout.", "open3d.visualization.gui.WidgetStack": "set a new widget to be delegated by this one. After set_widget, the previously delegated widget , will be abandon all calls to Widget\u2019s API will be conducted to widget. Before any set_widget call, this widget is invisible and disabled, seems it does not exist because it won\u2019t be drawn or in a layout." }, "pop_widget": { "open3d.visualization.gui.WidgetStack": "pop the topmost widget in the stack. The new topmost widgetof stack will be the widget on the show in GUI." }, "push_widget": { "open3d.visualization.gui.WidgetStack": "push a new widget onto the WidgetStack\u2019s stack, hiding whatever widget was there before and making the new widget visible." }, "set_on_top": { "open3d.visualization.gui.WidgetStack": "Callable[[widget] -> None], called while a widget becomes the topmost of stack after some widget is poppedout. It won\u2019t be called if a widget is pushed into stackby set_widget." }, "set_focus_widget": { "open3d.visualization.gui.Window": "Makes specified widget have text focus" }, "set_needs_layout": { "open3d.visualization.gui.Window": "Flags window to re-layout" }, "set_on_layout": { "open3d.visualization.gui.Window": "Sets a callback function that manually sets the frames of children of the window. Callback function will be called with one argument: gui.LayoutContext" }, "set_on_menu_item_activated": { "open3d.visualization.gui.Window": "Sets callback function for menu item: callback ()" }, "set_on_tick_event": { "open3d.visualization.gui.Window": "Sets callback for tick event. Callback takes no arguments and must return True if a redraw is needed (that is, if any widget has changed in any fashion) or False if nothing has changed" }, "is_active_window": { "open3d.visualization.gui.Window": "True if the window is currently the active window (read-only)" }, "renderer": { "open3d.visualization.gui.Window": "Gets the rendering.Renderer object for the Window" }, "theme": { "open3d.visualization.gui.Window": "Get\u2019s window\u2019s theme info" }, "copy_from": { "open3d.visualization.rendering.Camera": "Copies the settings from the camera passed as the argument into this camera" }, "get_far": { "open3d.visualization.rendering.Camera": "Returns the distance from the camera to the far plane" }, "get_field_of_view_type": { "open3d.visualization.rendering.Camera": "Returns the field of view type. Only valid if it was passed to set_projection ()." }, "get_model_matrix": { "open3d.visualization.rendering.Camera": "Returns the model matrix of the camera" }, "get_near": { "open3d.visualization.rendering.Camera": "Returns the distance from the camera to the near plane" }, "get_projection_matrix": { "open3d.visualization.rendering.Camera": "Returns the projection matrix of the camera" }, "get_view_matrix": { "open3d.visualization.rendering.Camera": "Returns the view matrix of the camera" }, "set_projection": { "open3d.visualization.rendering.Camera": "Overloaded function." }, "unproject": { "open3d.visualization.rendering.Camera": "unproject (x, y, z, view_width, view_height): takes the (x, y, z) location in the view, where x, y are the number of pixels from the upper left of the view, and z is the depth value. Returns the world coordinate (x\u2019, y\u2019, z\u2019)." }, "quality": { "open3d.visualization.rendering.ColorGrading": "Quality of color grading operations. High quality is more accurate but slower" }, "temperature": { "open3d.visualization.rendering.ColorGrading": "White balance color temperature" }, "tint": { "open3d.visualization.rendering.ColorGrading": "Tint on the green/magenta axis. Ranges from -1.0 to 1.0." }, "tone_mapping": { "open3d.visualization.rendering.ColorGrading": "The tone mapping algorithm to apply. Must be one of Linear, AcesLegacy, Aces, Filmic, Uchimura, Rienhard, Display Range (for debug)" }, "render_to_depth_image": { "open3d.visualization.rendering.OffscreenRenderer": "Renders scene depth buffer to a float image, blocking until the image is returned. Pixels range from 0 (near plane) to 1 (far plane). If z_in_view_space is set to True then pixels are pre-transformed into view space (i.e., distance from camera).", "open3d.visualization.rendering.Scene": "Renders the scene to a depth image. This can only be used in GUI app. To render without a window, use Application.render_to_depth_image. Pixels range from 0.0 (near plane) to 1.0 (far plane)" }, "add_model": { "open3d.visualization.rendering.Open3DScene": "Adds TriangleMeshModel to the scene." }, "geometry_is_visible": { "open3d.visualization.rendering.Open3DScene": "geometry_is_visible (name): returns True if the geometry name is visible" }, "get_geometry_transform": { "open3d.visualization.rendering.Open3DScene": "get_geometry_transform (name): returns the pose of the geometry name in the scene" }, "has_geometry": { "open3d.visualization.rendering.Open3DScene": "has_geometry (name): returns True if the geometry has been added to the scene, False otherwise", "open3d.visualization.rendering.Scene": "Returns True if a geometry with the provided name exists in the scene." }, "set_background_color": { "open3d.visualization.rendering.Open3DScene": "This function has been deprecated. Please use set_background () instead." }, "set_geometry_transform": { "open3d.visualization.rendering.Open3DScene": "set_geometry_transform (name, transform): sets the pose of the geometry name to transform" }, "set_lighting": { "open3d.visualization.rendering.Open3DScene": "Sets a simple lighting model. set_lighting (profile, sun_dir). The default value is set_lighting (Open3DScene.LightingProfile.MED_SHADOWS, (0.577, -0.577, -0.577))" }, "set_view_size": { "open3d.visualization.rendering.Open3DScene": "Sets the view size. This should not be used except for rendering to an image" }, "show_ground_plane": { "open3d.visualization.rendering.Open3DScene": "Toggles display of ground plane" }, "update_material": { "open3d.visualization.rendering.Open3DScene": "Applies the passed material to all the geometries" }, "bounding_box": { "open3d.visualization.rendering.Open3DScene": "The bounding box of all the items in the scene, visible and invisible" }, "camera": { "open3d.visualization.rendering.Open3DScene": "The camera object (read-only)" }, "downsample_threshold": { "open3d.visualization.rendering.Open3DScene": "Minimum number of points before downsampled point clouds are created and used when rendering speed is important" }, "view": { "open3d.visualization.rendering.Open3DScene": "The low level view associated with the scene" }, "add_texture": { "open3d.visualization.rendering.Renderer": "Adds a texture: add_texture (geometry.Image, bool). The first parameter is the image, the second parameter is optional and is True if the image is in the sRGB colorspace and False otherwise" }, "remove_texture": { "open3d.visualization.rendering.Renderer": "Deletes the texture. This does not remove the texture from any existing materials or GUI widgets, and must be done prior to this call." }, "set_clear_color": { "open3d.visualization.rendering.Renderer": "Sets the background color for the renderer, [r, g, b, a]. Applies to everything being rendered, so it essentially acts as the background color of the window" }, "update_texture": { "open3d.visualization.rendering.Renderer": "Updates the contents of the texture to be the new image, or returns False and does nothing if the image is a different size. It is more efficient to call update_texture () rather than removing and adding a new texture, especially when changes happen frequently, such as when implementing video. add_texture (geometry.Image, bool). The first parameter is the image, the second parameter is optional and is True if the image is in the sRGB colorspace and False otherwise" }, "add_camera": { "open3d.visualization.rendering.Scene": "Adds a camera to the scene" }, "add_directional_light": { "open3d.visualization.rendering.Scene": "Adds a directional light to the scene: add_point_light (name, color, intensity, cast_shadows)" }, "add_point_light": { "open3d.visualization.rendering.Scene": "Adds a point light to the scene: add_point_light (name, color, position, intensity, falloff, cast_shadows)" }, "add_spot_light": { "open3d.visualization.rendering.Scene": "Adds a spot light to the scene: add_point_light (name, color, position, direction, intensity, falloff, inner_cone_angle, outer_cone_angle, cast_shadows)" }, "enable_indirect_light": { "open3d.visualization.rendering.Scene": "Enables or disables indirect lighting" }, "enable_light_shadow": { "open3d.visualization.rendering.Scene": "Changes whether a point, spot, or directional light can cast shadows: enable_light_shadow (name, can_cast_shadows)" }, "remove_camera": { "open3d.visualization.rendering.Scene": "Removes the camera with the given name" }, "remove_light": { "open3d.visualization.rendering.Scene": "Removes the named light from the scene: remove_light (name)" }, "set_indirect_light": { "open3d.visualization.rendering.Scene": "Loads the indirect light. The name parameter is the name of the file to load" }, "set_indirect_light_intensity": { "open3d.visualization.rendering.Scene": "Sets the brightness of the indirect light" }, "set_sun_light": { "open3d.visualization.rendering.Scene": "Sets the parameters of the sun light: direction, color, intensity" }, "update_light_color": { "open3d.visualization.rendering.Scene": "Changes a point, spot, or directional light\u2019s color" }, "update_light_cone_angles": { "open3d.visualization.rendering.Scene": "Changes a spot light\u2019s inner and outer cone angles" }, "update_light_direction": { "open3d.visualization.rendering.Scene": "Changes a spot or directional light\u2019s direction" }, "update_light_falloff": { "open3d.visualization.rendering.Scene": "Changes a point or spot light\u2019s falloff" }, "update_light_intensity": { "open3d.visualization.rendering.Scene": "Changes a point, spot or directional light\u2019s intensity" }, "update_light_position": { "open3d.visualization.rendering.Scene": "Changes a point or spot light\u2019s position" }, "get_camera": { "open3d.visualization.rendering.View": "Returns the Camera associated with this View." }, "set_ambient_occlusion": { "open3d.visualization.rendering.View": "True to enable, False to disable ambient occlusion. Optionally, screen-space cone tracing may be enabled with ssct_enabled=True." }, "set_antialiasing": { "open3d.visualization.rendering.View": "True to enable, False to disable anti-aliasing. Note that this only impacts anti-aliasing post-processing. MSAA is controlled separately by set_sample_count. Temporal anti-aliasing may be optionally enabled with temporal=True." }, "set_color_grading": { "open3d.visualization.rendering.View": "Sets the parameters to be used for the color grading algorithms" }, "set_post_processing": { "open3d.visualization.rendering.View": "True to enable, False to disable post processing. Post processing effects include: color grading, ambient occlusion (and other screen space effects), and anti-aliasing." }, "set_sample_count": { "open3d.visualization.rendering.View": "Sets the sample count for MSAA. Set to 1 to disable MSAA. Typical values are 2, 4 or 8. The maximum possible value depends on the underlying GPU and OpenGL driver." }, "set_shadowing": { "open3d.visualization.rendering.View": "True to enable, false to enable all shadow mapping when rendering this View. When enabling shadow mapping you may also specify one of two shadow mapping algorithms: PCF (default) or VSM. Note: shadowing is enabled by default with PCF shadow mapping." }, "ByteSize": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Returns the size of the message in bytes.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Returns the size of the message in bytes.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Returns the size of the message in bytes." }, "Clear": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Clears the message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Clears the message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Clears the message." }, "ClearExtension": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Clears a message field.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Clears a message field.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Clears a message field." }, "ClearField": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Clears a message field.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Clears a message field.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Clears a message field." }, "CopyFrom": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Copies a protocol message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Copies a protocol message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Copies a protocol message into the current message." }, "DiscardUnknownFields": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Discards the unknown fields.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Discards the unknown fields.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Discards the unknown fields." }, "FindInitializationErrors": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Finds unset required fields.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Finds unset required fields.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Finds unset required fields." }, "FromString": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Creates new method instance from given serialized data.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Creates new method instance from given serialized data.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Creates new method instance from given serialized data." }, "HasExtension": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Checks if a message field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Checks if a message field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Checks if a message field is set." }, "HasField": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Checks if a message field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Checks if a message field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Checks if a message field is set." }, "IsInitialized": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Checks if all required fields of a protocol message are set.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Checks if all required fields of a protocol message are set.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Checks if all required fields of a protocol message are set." }, "ListFields": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Lists all set fields of a message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Lists all set fields of a message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Lists all set fields of a message." }, "MergeFrom": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Merges a protocol message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Merges a protocol message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Merges a protocol message into the current message." }, "MergeFromString": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Merges a serialized message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Merges a serialized message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Merges a serialized message into the current message." }, "ParseFromString": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Parses a serialized message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Parses a serialized message into the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Parses a serialized message into the current message." }, "RegisterExtension": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Registers an extension with the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Registers an extension with the current message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Registers an extension with the current message." }, "SerializePartialToString": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Serializes the message to a string, even if it isn\u2019t initialized.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Serializes the message to a string, even if it isn\u2019t initialized.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Serializes the message to a string, even if it isn\u2019t initialized." }, "SerializeToString": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Serializes the message to a string, only for initialized messages.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Serializes the message to a string, only for initialized messages.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Serializes the message to a string, only for initialized messages." }, "SetInParent": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Sets the has bit of the given field in its parent message.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Sets the has bit of the given field in its parent message.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Sets the has bit of the given field in its parent message." }, "UnknownFields": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Parse unknown field set", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Parse unknown field set", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Parse unknown field set" }, "WhichOneof": { "open3d.visualization.tensorboard_plugin.summary.Summary.Audio": "Returns the name of the field set inside a oneof, or None if no field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorProto": "Returns the name of the field set inside a oneof, or None if no field is set.", "open3d.visualization.tensorboard_plugin.summary.TensorShapeProto.Dim": "Returns the name of the field set inside a oneof, or None if no field is set." }, "add_3d": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Write 3D geometry data as TensorBoard summary for visualization with the Open3D for TensorBoard plugin." }, "add_audio": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add audio data to summary." }, "add_custom_scalars": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Create special chart by collecting charts tags in \u2018scalars\u2019. Note that this function can only be called once for each SummaryWriter () object. Because it only provides metadata to tensorboard, the function can be called before or after the training loop." }, "add_custom_scalars_marginchart": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Shorthand for creating marginchart. Similar to add_custom_scalars (), but the only necessary argument is tags, which should have exactly 3 elements." }, "add_custom_scalars_multilinechart": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Shorthand for creating multilinechart. Similar to add_custom_scalars (), but the only necessary argument is tags." }, "add_embedding": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add embedding projector data to summary." }, "add_figure": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Render matplotlib figure into an image and add it to summary." }, "add_graph": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add graph data to summary." }, "add_histogram": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add histogram to summary." }, "add_histogram_raw": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Adds histogram with raw data." }, "add_hparams": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add a set of hyperparameters to be compared in TensorBoard." }, "add_image": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add image data to summary." }, "add_image_with_boxes": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add image and draw bounding boxes on the image." }, "add_images": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add batched image data to summary." }, "add_mesh": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add meshes or 3D point clouds to TensorBoard. The visualization is based on Three.js, so it allows users to interact with the rendered object. Besides the basic definitions such as vertices, faces, users can further provide camera parameter, lighting condition, etc. Please check __URL__ for advanced usage." }, "add_pr_curve": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Adds precision recall curve. Plotting a precision-recall curve lets you understand your model\u2019s performance under different threshold settings. With this function, you provide the ground truth labeling (T/F) and prediction confidence (usually the output of your model) for each target. The TensorBoard UI will let you choose the threshold interactively." }, "add_pr_curve_raw": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Adds precision recall curve with raw data." }, "add_scalar": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add scalar data to summary." }, "add_scalars": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Adds many scalar data to summary." }, "add_text": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add text data to summary." }, "add_video": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Add video data to summary." }, "flush": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Flushes the event file to disk. Call this method to make sure that all pending events have been written to disk." }, "get_logdir": { "open3d.visualization.tensorboard_plugin.summary.SummaryWriter": "Returns the directory where event files will be written." } }
